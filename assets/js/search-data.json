{
  
    
        "post0": {
            "title": "pytorch-widedeep, deep learning for tabular data II: advanced use",
            "content": "This is the second of the two posts introducing pytorch-widedeep, a flexible package to combine tabular data with text and images. . In the first post I described pytorch-widedeep&#39;s data preprocessing utilities, the main components of a WideDeep model and a quick example to illustrate the basic use of the library. In this post I will use a series of example to dig deeper into the many options pytorch-widedeep offers as we build wide and deep models. . 1. Binary classification with varying parameters . Let&#39;s start by using again the adult census dataset. . Before moving any further, let me emphasize that, as we go through the examples, one should not pay excessive (or any) attention to the loss or the metrics in the sense that the input parameters are not selected to obtain &quot;state of the art&quot;, but to illustrate usability. . A proper benchmarking exercise will be carried out in a future post. Having said that, and without further ado, let&#39;s start. . #collapse-hide import pandas as pd import numpy as np adult = pd.read_csv(&quot;data/adult/adult.csv.zip&quot;) adult.columns = [c.replace(&quot;-&quot;, &quot;_&quot;) for c in adult.columns] adult[&quot;income_label&quot;] = (adult[&quot;income&quot;].apply(lambda x: &quot;&gt;50K&quot; in x)).astype(int) adult.drop(&quot;income&quot;, axis=1, inplace=True) for c in adult.columns: if adult[c].dtype == &#39;O&#39;: adult[c] = adult[c].apply(lambda x: &quot;unknown&quot; if x == &quot;?&quot; else x) adult[c] = adult[c].str.lower() . . adult.head() . age workclass fnlwgt education educational_num marital_status occupation relationship race gender capital_gain capital_loss hours_per_week native_country income_label . 0 25 | private | 226802 | 11th | 7 | never-married | machine-op-inspct | own-child | black | male | 0 | 0 | 40 | united-states | 0 | . 1 38 | private | 89814 | hs-grad | 9 | married-civ-spouse | farming-fishing | husband | white | male | 0 | 0 | 50 | united-states | 0 | . 2 28 | local-gov | 336951 | assoc-acdm | 12 | married-civ-spouse | protective-serv | husband | white | male | 0 | 0 | 40 | united-states | 1 | . 3 44 | private | 160323 | some-college | 10 | married-civ-spouse | machine-op-inspct | husband | black | male | 7688 | 0 | 40 | united-states | 1 | . 4 18 | unknown | 103497 | some-college | 10 | never-married | unknown | own-child | white | female | 0 | 0 | 30 | united-states | 0 | . if you read the first post you will be familiar with the code below: . import torch from pytorch_widedeep.preprocessing import WidePreprocessor, DensePreprocessor from pytorch_widedeep.initializers import KaimingNormal, XavierNormal from pytorch_widedeep.callbacks import ModelCheckpoint, LRHistory, EarlyStopping from pytorch_widedeep.metrics import Accuracy, Recall from pytorch_widedeep.optim import RAdam from pytorch_widedeep.models import Wide, DeepDense, WideDeep wide_cols = [&#39;education&#39;, &#39;relationship&#39;,&#39;workclass&#39;,&#39;occupation&#39;,&#39;native_country&#39;,&#39;gender&#39;] crossed_cols = [(&#39;education&#39;, &#39;occupation&#39;), (&#39;native_country&#39;, &#39;occupation&#39;)] cat_embed_cols = [(&#39;education&#39;,16), (&#39;relationship&#39;,8), (&#39;workclass&#39;,16), (&#39;occupation&#39;,16),(&#39;native_country&#39;,16)] continuous_cols = [&quot;age&quot;,&quot;hours_per_week&quot;] target_col = &#39;income_label&#39; # TARGET target = adult[target_col].values # WIDE preprocess_wide = WidePreprocessor(wide_cols=wide_cols, crossed_cols=crossed_cols) X_wide = preprocess_wide.fit_transform(adult) # DEEP preprocess_deep = DensePreprocessor(embed_cols=cat_embed_cols, continuous_cols=continuous_cols) X_deep = preprocess_deep.fit_transform(adult) . wide = Wide(wide_dim=np.unique(X_wide).shape[0], pred_dim=1) # We can add dropout and batchnorm to the dense layers deepdense = DeepDense(hidden_layers=[64,32], dropout=[0.5, 0.5], batchnorm=True, deep_column_idx=preprocess_deep.deep_column_idx, embed_input=preprocess_deep.embeddings_input, continuous_cols=continuous_cols) model = WideDeep(wide=wide, deepdense=deepdense) . Let&#39;s have a look to the model that we will be running: . model . WideDeep( (wide): Wide( (wide_linear): Embedding(797, 1, padding_idx=0) ) (deepdense): Sequential( (0): DeepDense( (embed_layers): ModuleDict( (emb_layer_education): Embedding(17, 16) (emb_layer_native_country): Embedding(43, 16) (emb_layer_occupation): Embedding(16, 16) (emb_layer_relationship): Embedding(7, 8) (emb_layer_workclass): Embedding(10, 16) ) (embed_dropout): Dropout(p=0.0, inplace=False) (dense): Sequential( (dense_layer_0): Sequential( (0): Linear(in_features=74, out_features=64, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): Dropout(p=0.5, inplace=False) ) (dense_layer_1): Sequential( (0): Linear(in_features=64, out_features=32, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): BatchNorm1d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): Dropout(p=0.5, inplace=False) ) ) ) (1): Linear(in_features=32, out_features=1, bias=True) ) ) . Now we will define the set up for each model component, including optimizers, learning rate schedulers and initializers: . # Optimizers wide_opt = torch.optim.Adam(model.wide.parameters(), lr=0.03) deep_opt = RAdam(model.deepdense.parameters(), lr=0.1) # LR Schedulers wide_sch = torch.optim.lr_scheduler.StepLR(wide_opt, step_size=3) deep_sch = torch.optim.lr_scheduler.StepLR(deep_opt, step_size=5) # Component-dependent settings as Dict optimizers = {&#39;wide&#39;: wide_opt, &#39;deepdense&#39;:deep_opt} schedulers = {&#39;wide&#39;: wide_sch, &#39;deepdense&#39;:deep_sch} initializers = {&#39;wide&#39;: KaimingNormal, &#39;deepdense&#39;:XavierNormal} # General settings as List callbacks = [LRHistory(n_epochs=10), EarlyStopping, ModelCheckpoint(filepath=&#39;model_weights/wd_out&#39;)] metrics = [Accuracy, Recall] . Compile and fit! . model.compile(method=&#39;binary&#39;, optimizers=optimizers, lr_schedulers=schedulers, initializers=initializers, callbacks=callbacks, metrics=metrics, verbose=False) . model.fit(X_wide=X_wide, X_deep=X_deep, target=target, n_epochs=10, batch_size=256, val_split=0.2) . #collapse-hide import matplotlib.pyplot as plt %matplotlib inline import seaborn as sns sns.set() . . #collapse-hide plt.figure(figsize=(15,8)) plt.subplot(2,2,1) plt.plot(model.history._history[&#39;train_loss&#39;], label=&quot;train&quot;) plt.plot(model.history._history[&#39;val_loss&#39;], label=&quot;val&quot;) plt.legend(fontsize=13) plt.xlabel(&quot;n epochs&quot;, fontsize=13) plt.ylabel(&quot;Loss&quot;, fontsize=13) plt.subplot(2,2,2) plt.plot(model.history._history[&#39;train_acc&#39;], label=&quot;train&quot;) plt.plot(model.history._history[&#39;val_acc&#39;], label=&quot;val&quot;) plt.legend(fontsize=13) plt.xlabel(&quot;n epochs&quot;, fontsize=13) plt.ylabel(&quot;Accuracy&quot;, fontsize=13) plt.subplot(2,2,3) plt.plot(model.lr_history[&#39;lr_wide_0&#39;], label=&quot;wide&quot;) plt.plot(model.lr_history[&#39;lr_deepdense_0&#39;], label=&quot;deepdense&quot;) plt.legend(fontsize=13) plt.xlabel(&quot;n epochs&quot;, fontsize=13) plt.ylabel(&quot;learning rate&quot;, fontsize=13) . . Text(0, 0.5, &#39;learning rate&#39;) . As we can see from the plots, the learning rate effectively decreases by a factor of 0.1 (the default) after the corresponding step_size for each component. Note that the keys in the model.lr_history dictionary have a suffix _0. This is because if you pass different parameter groups to the torch optimizers, these will also be recorded. We&#39;ll see this in the regression example, in the next section. . Before I move to the next section let me just mention that the WideDeep class comes with a useful method to &quot;rescue&quot; the learned embeddings, very creatively called get_embeddings. For example, let&#39;s say I want to use the embeddings learned for the different levels of the categorical feature education. These can be access via: . education_embed = model.get_embeddings( col_name=&#39;education&#39;, cat_encoding_dict=preprocess_deep.label_encoder.encoding_dict ) education_embed[&#39;doctorate&#39;] . array([ 0.23485082, 0.41219023, 0.12688892, 0.08351105, -0.29780635, -0.5321735 , -0.24137467, -0.49889308, 0.37074092, -0.11963069, 0.7072009 , 0.5613647 , -0.0930844 , -0.5126964 , -0.05072869, -0.40419328], dtype=float32) . 2. Regression combining tabular, text and images . For this example we will use a small sample (so you can run it locally in a laptop) of the Airbnb listings dataset in London. . In case you are interested in all details, I did prepared the original dataset for this post, and all the code can be found at the airbnb_data_preprocessing.py, here. After such preprocessing the data looks like this: . #collapse-hide airbnb = pd.read_csv(&#39;data/airbnb/airbnb_sample.csv&#39;) . . airbnb.head(1) . id host_id description host_listings_count host_identity_verified neighbourhood_cleansed latitude longitude is_location_exact property_type room_type accommodates bathrooms bedrooms beds guests_included minimum_nights instant_bookable cancellation_policy has_house_rules host_gender accommodates_catg guests_included_catg minimum_nights_catg host_listings_count_catg bathrooms_catg bedrooms_catg beds_catg amenity_24-hour_check-in amenity__toilet amenity_accessible-height_bed amenity_accessible-height_toilet amenity_air_conditioning amenity_air_purifier amenity_alfresco_bathtub amenity_amazon_echo amenity_baby_bath amenity_baby_monitor amenity_babysitter_recommendations amenity_balcony amenity_bath_towel amenity_bathroom_essentials amenity_bathtub amenity_bathtub_with_bath_chair amenity_bbq_grill amenity_beach_essentials amenity_beach_view amenity_beachfront amenity_bed_linens amenity_bedroom_comforts ... amenity_roll-in_shower amenity_room-darkening_shades amenity_safety_card amenity_sauna amenity_self_check-in amenity_shampoo amenity_shared_gym amenity_shared_hot_tub amenity_shared_pool amenity_shower_chair amenity_single_level_home amenity_ski-in_ski-out amenity_smart_lock amenity_smart_tv amenity_smoke_detector amenity_smoking_allowed amenity_soaking_tub amenity_sound_system amenity_stair_gates amenity_stand_alone_steam_shower amenity_standing_valet amenity_steam_oven amenity_stove amenity_suitable_for_events amenity_sun_loungers amenity_table_corner_guards amenity_tennis_court amenity_terrace amenity_toilet_paper amenity_touchless_faucets amenity_tv amenity_walk-in_shower amenity_warming_drawer amenity_washer amenity_washer_dryer amenity_waterfront amenity_well-lit_path_to_entrance amenity_wheelchair_accessible amenity_wide_clearance_to_shower amenity_wide_doorway_to_guest_bathroom amenity_wide_entrance amenity_wide_entrance_for_guests amenity_wide_entryway amenity_wide_hallways amenity_wifi amenity_window_guards amenity_wine_cooler security_deposit extra_people yield . 0 13913.jpg | 54730 | My bright double bedroom with a large window has a relaxed feeling! It comfortably fits one or t... | 4.0 | f | Islington | 51.56802 | -0.11121 | t | apartment | private_room | 2 | 1.0 | 1.0 | 0.0 | 1 | 1 | f | moderate | 1 | female | 2 | 1 | 1 | 3 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | ... | 1 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 100.0 | 15.0 | 12.0 | . 1 rows × 223 columns . Let&#39;s define what will go through the wide and deep components . # wide crossed_cols = ([&quot;property_type&quot;, &quot;room_type&quot;],) already_dummies = [c for c in airbnb.columns if &quot;amenity&quot; in c] + [&quot;has_house_rules&quot;] wide_cols = [ &quot;is_location_exact&quot;, &quot;property_type&quot;, &quot;room_type&quot;, &quot;host_gender&quot;, &quot;instant_bookable&quot;, ] + already_dummies # deepdense cat_embed_cols = [(c, 16) for c in airbnb.columns if &quot;catg&quot; in c] + [ (&quot;neighbourhood_cleansed&quot;, 64), (&quot;cancellation_policy&quot;, 16), ] continuous_cols = [&quot;latitude&quot;, &quot;longitude&quot;, &quot;security_deposit&quot;, &quot;extra_people&quot;] already_standard = [&quot;latitude&quot;, &quot;longitude&quot;] # deeptext (at this day and age you might want to use other word vectors...) text_col = &quot;description&quot; word_vectors_path = &quot;data/glove.6B/glove.6B.100d.txt&quot; # deepimage img_col = &quot;id&quot; img_path = &quot;data/airbnb/property_picture&quot; # target target_col = &quot;yield&quot; . Note the following: columns that are already dummies (defined as already_dummies), are treated as any other wide column. Internally, nothing will really happen to them. They will just add one entry to the embedding lookup table. . On the other hand, you will see that among the columns that will be passed through the deepdense component we have already_standard columns, which are longitude and latitude. These are columns for which it makes no sense to standardize them. However, at the same time, one would not advise to pass inputs to the network that are in a very different scale. Nonetheless, I decided to include a already_standard parameter in the DensePreprocessor and the columns passed as already_standard will not be normalized. . import os import torch from pytorch_widedeep.preprocessing import WidePreprocessor, DensePreprocessor, TextPreprocessor, ImagePreprocessor from pytorch_widedeep.models import Wide, DeepDense, DeepText, DeepImage, WideDeep from pytorch_widedeep.initializers import * from pytorch_widedeep.callbacks import * . target = airbnb[target_col].values wide_preprocessor = WidePreprocessor(wide_cols=wide_cols, crossed_cols=crossed_cols) X_wide = wide_preprocessor.fit_transform(airbnb) deep_preprocessor = DensePreprocessor(embed_cols=cat_embed_cols, continuous_cols=continuous_cols, already_standard=already_standard) X_deep = deep_preprocessor.fit_transform(airbnb) text_preprocessor = TextPreprocessor(word_vectors_path=word_vectors_path, text_col=text_col) X_text = text_preprocessor.fit_transform(airbnb) image_preprocessor = ImagePreprocessor(img_col=img_col, img_path=img_path) X_images = image_preprocessor.fit_transform(airbnb) . The vocabulary contains 2192 tokens Indexing word vectors... Loaded 400000 word vectors Preparing embeddings matrix... 2175 words in the vocabulary had data/glove.6B/glove.6B.100d.txt vectors and appear more than 5 times Reading Images from data/airbnb/property_picture . 4%|▍ | 40/1001 [00:00&lt;00:02, 395.94it/s] . Resizing . 100%|██████████| 1001/1001 [00:02&lt;00:00, 392.30it/s] . Computing normalisation metrics . At this stage the data is ready to be passed through the model. However, instead of building a &quot;simple&quot; model that collects the wide, deepdense, deeptext and deepimage component, I am going to use this opportunity to illustrate pytorch-widedepp&#39;s flexibility to build wide and deep models. I like to call this, getting into Kaggle mode. . First we define the components of the model... . wide = Wide(wide_dim=np.unique(X_wide).shape[0], pred_dim=1) deepdense = DeepDense(hidden_layers=[128,64], dropout=[0.5, 0.5], deep_column_idx=deep_preprocessor.deep_column_idx, embed_input=deep_preprocessor.embeddings_input, continuous_cols=continuous_cols) deeptext = DeepText(vocab_size=len(text_preprocessor.vocab.itos), hidden_dim=64, n_layers=2, rnn_dropout=0.5, embedding_matrix=text_preprocessor.embedding_matrix) deepimage = DeepImage(pretrained=True, freeze=7, head_layers=[512, 256, 128]) . ...and, as we build the model, add a fully connected head via the input parameters (could also be used via the additional component/parameter deephead) . model = WideDeep(wide=wide, deepdense=deepdense, deeptext=deeptext, deepimage=deepimage, head_layers=[128, 64]) . Let&#39;s have a look to the model . model . WideDeep( (wide): Wide( (wide_linear): Embedding(357, 1, padding_idx=0) ) (deepdense): DeepDense( (embed_layers): ModuleDict( (emb_layer_accommodates_catg): Embedding(4, 16) (emb_layer_bathrooms_catg): Embedding(4, 16) (emb_layer_bedrooms_catg): Embedding(5, 16) (emb_layer_beds_catg): Embedding(5, 16) (emb_layer_cancellation_policy): Embedding(6, 16) (emb_layer_guests_included_catg): Embedding(4, 16) (emb_layer_host_listings_count_catg): Embedding(5, 16) (emb_layer_minimum_nights_catg): Embedding(4, 16) (emb_layer_neighbourhood_cleansed): Embedding(33, 64) ) (embed_dropout): Dropout(p=0.0, inplace=False) (dense): Sequential( (dense_layer_0): Sequential( (0): Linear(in_features=196, out_features=128, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): Dropout(p=0.5, inplace=False) ) (dense_layer_1): Sequential( (0): Linear(in_features=128, out_features=64, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): Dropout(p=0.5, inplace=False) ) ) ) (deeptext): DeepText( (word_embed): Embedding(2192, 100, padding_idx=1) (rnn): LSTM(100, 64, num_layers=2, batch_first=True, dropout=0.5) ) (deepimage): DeepImage( (backbone): Sequential( (0): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False) (4): Sequential( (0): BasicBlock( (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) (1): BasicBlock( (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (5): Sequential( (0): BasicBlock( (conv1): Conv2d(64, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (downsample): Sequential( (0): Conv2d(64, 128, kernel_size=(1, 1), stride=(2, 2), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (1): BasicBlock( (conv1): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (6): Sequential( (0): BasicBlock( (conv1): Conv2d(128, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (downsample): Sequential( (0): Conv2d(128, 256, kernel_size=(1, 1), stride=(2, 2), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (1): BasicBlock( (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (7): Sequential( (0): BasicBlock( (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (downsample): Sequential( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (1): BasicBlock( (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) (8): AdaptiveAvgPool2d(output_size=(1, 1)) ) (imagehead): Sequential( (dense_layer_0): Sequential( (0): Linear(in_features=512, out_features=256, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): Dropout(p=0.0, inplace=False) ) (dense_layer_1): Sequential( (0): Linear(in_features=256, out_features=128, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): Dropout(p=0.0, inplace=False) ) ) ) (deephead): Sequential( (head_layer_0): Sequential( (0): Linear(in_features=256, out_features=128, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): Dropout(p=0.0, inplace=False) ) (head_layer_1): Sequential( (0): Linear(in_features=128, out_features=64, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): Dropout(p=0.0, inplace=False) ) (head_out): Linear(in_features=64, out_features=1, bias=True) ) ) . This is a big model, so let me go component by component. . wide: simple linear model implemented via an Embedding layer . | deepdense: embeddings concatenated to categorical columns that are then passed through two dense layers with the following sizes [196 $ rightarrow$ 128 $ rightarrow$ 64]. . | deeptext: two stacked LTSMs that will received the pre-trained glove wordvectors and output a last hidden state of dim 64 (this would be 128 if we had used bidirectional = True) . | deepimage: a pre-trained ResNet 18 model where only the last Sequential block (7) will be trained. The rest will remain &quot;frozen&quot;. on top of it we have imagehead which is just a Sequential model comprised of two dense layers with the following sizes [512 $ rightarrow$ 256 $ rightarrow$ 128] . | deephead: on top of the 3 deep components we have a final component referred as deephead (this would correspond to the architecture 2 described in the first post). This component will receive the concatenated output from all the deep components, and pass it through a further collection of dense layers. In this case the sizes are [256 $ rightarrow$ 64 $ rightarrow$ 1]. We input 256 because the output dim from deepdense is 64, the output dim from deeptext is 64 and the output dim from deeptext is 128. The final deephead output dim is 1 because we are performing a regression, i.e. one output neuron with no activation function. . | Let&#39;s go even a step further and use different optimizers, initializers and schedulers for different components. Moreover, let&#39;s use a different learning rate for different parameter groups in the case of the deepdense, remember, this is Kaggle mode. . # Optimizers. Different parameter groups for the deepdense component will use different lr deep_params = [] for childname, child in model.named_children(): if childname == &#39;deepdense&#39;: for n,p in child.named_parameters(): if &quot;emb_layer&quot; in n: deep_params.append({&#39;params&#39;: p, &#39;lr&#39;: 0.01}) else: deep_params.append({&#39;params&#39;: p, &#39;lr&#39;: 0.03}) wide_opt = torch.optim.Adam(model.wide.parameters(), lr=0.03) deep_opt = torch.optim.Adam(deep_params) text_opt = RAdam(model.deeptext.parameters()) img_opt = RAdam(model.deepimage.parameters()) head_opt = torch.optim.AdamW(model.deephead.parameters()) optimizers = {&#39;wide&#39;: wide_opt, &#39;deepdense&#39;:deep_opt, &#39;deeptext&#39;:text_opt, &#39;deepimage&#39;: img_opt, &#39;deephead&#39;: head_opt} # schedulers wide_sch = torch.optim.lr_scheduler.StepLR(wide_opt, step_size=5) deep_sch = torch.optim.lr_scheduler.MultiStepLR(deep_opt, milestones=[3,8]) text_sch = torch.optim.lr_scheduler.StepLR(text_opt, step_size=5) img_sch = torch.optim.lr_scheduler.MultiStepLR(deep_opt, milestones=[3,8]) head_sch = torch.optim.lr_scheduler.StepLR(head_opt, step_size=5) schedulers = {&#39;wide&#39;: wide_sch, &#39;deepdense&#39;:deep_sch, &#39;deeptext&#39;:text_sch, &#39;deepimage&#39;: img_sch, &#39;deephead&#39;: head_sch} # initializers initializers = {&#39;wide&#39;: KaimingNormal, &#39;deepdense&#39;:KaimingNormal, &#39;deeptext&#39;:KaimingNormal(pattern=r&quot;^(?!.*word_embed).*$&quot;), # do not initialize the pre-trained word-vectors! &#39;deepimage&#39;:KaimingNormal} # transforms and callbacks mean = [0.406, 0.456, 0.485] #BGR std = [0.225, 0.224, 0.229] #BGR transforms = [ToTensor, Normalize(mean=mean, std=std)] callbacks = [LRHistory(n_epochs=10), EarlyStopping, ModelCheckpoint(filepath=&#39;model_weights/wd_out&#39;)] . Note that, since we will use pre-trained word embeddings, we do not want to initialize these embeddings. However you might still want to initialize the other layers in the deeptext component. This is not a problem, you can do that with the parameter pattern and your knowledge on regular expressions. In the deeptext initializer definition above: . KaimingNormal(pattern=r&quot;^(?!.*word_embed).*$&quot;) . I am NOT initializing parameters whose name contains the string word_embed. . So...let&#39;s compile and run, which is as easy as: . model.compile(method=&#39;regression&#39;, initializers=initializers, optimizers=optimizers, lr_schedulers=schedulers, callbacks=callbacks, transforms=transforms) model.fit(X_wide=X_wide, X_deep=X_deep, X_text=X_text, X_img=X_images, target=target, n_epochs=1, batch_size=32, val_split=0.2) . 0%| | 0/25 [00:00&lt;?, ?it/s] . Training . epoch 1: 100%|██████████| 25/25 [01:37&lt;00:00, 3.91s/it, loss=1.23e+4] valid: 100%|██████████| 7/7 [00:15&lt;00:00, 2.26s/it, loss=1.24e+4] . As I mentioned early in the post, please, do not focus on the success metric/loss (mse in this case). I am just using a very small sample of the dataset and some &quot;random&quot; set up. I just want to illustrate usability. A benchmark post will come in the &quot;no-so-distant future&quot;. . 3. Warm up routines . When running .fit, we can choose to first &quot;warm up&quot; each model individually (similarly to fine-tunning if the model was pre-trained, but this is a general functionality, i.e. there is no need of a pre-trained model) before the joined training begins. . pytorch-widedeep implements 3 different warming up routines: . Warm up all trainable layers at once with a triangular one-cycle learning rate (referred as slanted triangular learning rates in Howard &amp; Ruder 2018 [1]). See here for an example on this routine for a simpler wide + deepdense model. . | Gradual warm up inspired by the work of Felbo et al., 2017 [2] for fine-tunning . | Gradual warm up inspired by the work of Howard &amp; Ruder 2018 for fine-tunning . | Currently warming up is only supported without a fully connected deephead, i.e. if deephead=None. In addition, Felbo and Howard routines only applied to the deeptext and deepimage components. The wide and deepdense components can also be warmed up, but together, following the first of the 3 routines described before. . Let me briefly describe the &quot;Felbo&quot; and &quot;Howard&quot; routines before showing how to use them. . 3.1 The Felbo warm-up routine . The Felbo warm-up routine can be illustrated by the following figure: . . Figure 1. The process in the figure can be described as follows: warm up (or train) the last layer for one epoch using a one cycle triangular learning rate. Then warm up the next deeper layer for one epoch, with a learning rate that is a factor of 2.5 lower than the previous learning rate (the 2.5 factor is fixed) while freezing the already warmed up layer(s). Repeat untill all individual layers are warmed. Then warm one last epoch with all warmed layers trainable. The vanishing color gradient in the figure attempts to illustrate the decreasing learning rate. . Note that this is not identical to the Fine-Tunning routine described in Felbo et al, 2017, this is why I used the word &#39;inspired&#39; before. . 3.1 The Howard warm-up routine . The Howard routine can be illustrated by the following figure: . . Figure 2. The process in the figure can be described as follows: warm up (or train) the last layer for one epoch using a one cycle triangular learning rate. Then warm up the next deeper layer for one epoch, with a learning rate that is a factor of 2.5 lower than the previous learning rate (the 2.5 factor is fixed) while keeping the already warmed up layer(s) trainable. Repeat. The vanishing color gradient in the figure attempts to illustrate the decreasing learning rate. . Note that I write &quot;warm up (or train) the last layer for one epoch [...]&quot;. However, in practice the user will have to specify the order of the layers to be warmed up. This is another reason why I wrote that the warm up routines I have implemented are inspired by the work of Felbo and Howard and not identical to their implemenations. . The felbo and howard routines can be accessed with via the warm up parameters. Let&#39;s have a look: . wide = Wide(wide_dim=np.unique(X_wide).shape[0], pred_dim=1) deepdense = DeepDense( hidden_layers=[64,32], dropout=[0.2,0.2], deep_column_idx=deep_preprocessor.deep_column_idx, embed_input=deep_preprocessor.embeddings_input, continuous_cols=continuous_cols) deeptext = DeepText(vocab_size=len(text_preprocessor.vocab.itos), hidden_dim=64, n_layers=3, rnn_dropout=0.5, embedding_matrix=text_preprocessor.embedding_matrix) deepimage = DeepImage(pretrained=True, head_layers=None) model = WideDeep(wide=wide, deepdense=deepdense, deeptext=deeptext, deepimage=deepimage) model.compile(method=&#39;regression&#39;) . This is a similar model to the one before but without the final deephead. There, we saw that the deepimage component, identical to the one discussed here, is comprised by a Sequential model that is a ResNet backbone and a Linear Layer. . In this example, I warm up the layers in the ResNet backbone, apart from the first sequence [Conv2d -&gt; BatchNorm2d -&gt; ReLU -&gt; MaxPool2d], and the Linear layer. . This is done as follows: . first_child = list(model.deepimage.children())[0] img_layers = list(first_child.backbone.children())[4:8] + [list(model.deepimage.children())[1]] . warm_img_layers = img_layers[::-1] . model.fit( X_wide=X_wide, X_deep=X_deep, X_text=X_text, X_img=X_images, target=target, n_epochs=1, batch_size=32, val_split=0.2, warm_up=True, warm_epochs=1, warm_deepimage_gradual=True, warm_deepimage_layers=warm_img_layers, warm_deepimage_max_lr=0.01, warm_routine=&#39;howard&#39; ) . 0%| | 0/25 [00:00&lt;?, ?it/s] . Warming up wide for 1 epochs . epoch 1: 100%|██████████| 25/25 [00:00&lt;00:00, 28.55it/s, loss=1.59e+4] 0%| | 0/25 [00:00&lt;?, ?it/s] . Warming up deepdense for 1 epochs . epoch 1: 100%|██████████| 25/25 [00:00&lt;00:00, 44.05it/s, loss=1.25e+4] 0%| | 0/25 [00:00&lt;?, ?it/s] . Warming up deeptext for 1 epochs . epoch 1: 100%|██████████| 25/25 [00:03&lt;00:00, 7.85it/s, loss=1.68e+4] 0%| | 0/25 [00:00&lt;?, ?it/s] . Warming up deepimage, layer 1 of 5 . epoch 1: 100%|██████████| 25/25 [01:12&lt;00:00, 2.88s/it, loss=1.34e+4] 0%| | 0/25 [00:00&lt;?, ?it/s] . Warming up deepimage, layer 2 of 5 . epoch 1: 100%|██████████| 25/25 [01:39&lt;00:00, 3.99s/it, loss=1.1e+4] 0%| | 0/25 [00:00&lt;?, ?it/s] . Warming up deepimage, layer 3 of 5 . epoch 1: 100%|██████████| 25/25 [01:59&lt;00:00, 4.78s/it, loss=1.08e+4] 0%| | 0/25 [00:00&lt;?, ?it/s] . Warming up deepimage, layer 4 of 5 . epoch 1: 100%|██████████| 25/25 [02:25&lt;00:00, 5.81s/it, loss=1.05e+4] 0%| | 0/25 [00:00&lt;?, ?it/s] . Warming up deepimage, layer 5 of 5 . epoch 1: 100%|██████████| 25/25 [03:08&lt;00:00, 7.53s/it, loss=1.08e+4] 0%| | 0/25 [00:00&lt;?, ?it/s] . Training . epoch 1: 100%|██████████| 25/25 [02:12&lt;00:00, 5.32s/it, loss=1.61e+4] valid: 100%|██████████| 7/7 [00:16&lt;00:00, 2.43s/it, loss=1.4e+4] . 4. Custom model . So far we have used the components that come with pytorch-widedee. However, as I mentioned in the first post, it is very likely that the user wants to use custom models for the deeptext and deepimage components. This is easily attainable by...well...simply passing your own model. . You should just remember that the model must return the last layer of activations (and NOT the predictions) and must contained an attribute called output_dim with the output dimension of that last layer. . For example, let&#39;s say we want to use as deeptext a very simple stack of 2 bidirectional GRUs. . from torch import nn class MyDeepText(nn.Module): def __init__(self, vocab_size, padding_idx=1, embed_dim=100, hidden_dim=64): super(MyDeepText, self).__init__() # word/token embeddings self.word_embed = nn.Embedding( vocab_size, embed_dim, padding_idx=padding_idx ) # stack of RNNs self.rnn = nn.GRU( embed_dim, hidden_dim, num_layers=2, bidirectional=True, batch_first=True, ) # Remember, this must be defined. If not WideDeep will through an error self.output_dim = hidden_dim * 2 def forward(self, X): embed = self.word_embed(X.long()) o, h = self.rnn(embed) return torch.cat((h[-2], h[-1]), dim=1) . And from here, &quot;proceed as usual&quot; . wide = Wide(wide_dim=np.unique(X_wide).shape[0], pred_dim=1) deepdense = DeepDense( hidden_layers=[64,32], dropout=[0.2,0.2], deep_column_idx=deep_preprocessor.deep_column_idx, embed_input=deep_preprocessor.embeddings_input, continuous_cols=continuous_cols) mydeeptext = MyDeepText(vocab_size=len(text_preprocessor.vocab.itos)) model = WideDeep(wide=wide, deepdense=deepdense, deeptext=mydeeptext) model.compile(method=&#39;regression&#39;) . model . WideDeep( (wide): Wide( (wide_linear): Embedding(357, 1, padding_idx=0) ) (deepdense): Sequential( (0): DeepDense( (embed_layers): ModuleDict( (emb_layer_accommodates_catg): Embedding(4, 16) (emb_layer_bathrooms_catg): Embedding(4, 16) (emb_layer_bedrooms_catg): Embedding(5, 16) (emb_layer_beds_catg): Embedding(5, 16) (emb_layer_cancellation_policy): Embedding(6, 16) (emb_layer_guests_included_catg): Embedding(4, 16) (emb_layer_host_listings_count_catg): Embedding(5, 16) (emb_layer_minimum_nights_catg): Embedding(4, 16) (emb_layer_neighbourhood_cleansed): Embedding(33, 64) ) (embed_dropout): Dropout(p=0.0, inplace=False) (dense): Sequential( (dense_layer_0): Sequential( (0): Linear(in_features=196, out_features=64, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): Dropout(p=0.2, inplace=False) ) (dense_layer_1): Sequential( (0): Linear(in_features=64, out_features=32, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): Dropout(p=0.2, inplace=False) ) ) ) (1): Linear(in_features=32, out_features=1, bias=True) ) (deeptext): Sequential( (0): MyDeepText( (word_embed): Embedding(2192, 100, padding_idx=1) (rnn): GRU(100, 64, num_layers=2, batch_first=True, bidirectional=True) ) (1): Linear(in_features=128, out_features=1, bias=True) ) ) . model.fit(X_wide=X_wide, X_deep=X_deep, X_text=X_text, target=target, n_epochs=1, batch_size=32, val_split=0.2) . 0%| | 0/25 [00:00&lt;?, ?it/s] . Training . epoch 1: 100%|██████████| 25/25 [00:04&lt;00:00, 6.16it/s, loss=1.74e+4] valid: 100%|██████████| 7/7 [00:00&lt;00:00, 21.47it/s, loss=9.35e+3] . 5. Conclusion . In this second post I tried to illustrate in detail the different functionalities of the pytorch-widedeep package, and how these can be used to customize each of the four potential components of the WideDeep model that can be built with pytorch-widedeep. I have also describe the warm-up routines that can be used to &quot;warm-up&quot; each individual component before the joined training and finally, how custom models, &quot;external&quot; to pytorch-widedeep can be used in combination with the package. . However, this is not the end of the journey. As you will have seen, there is an &quot;imbalance in the pytorch-widedeep force&quot;, in the sense that while fully pre-trained models are incorporated for the deepimage component, this is not the case for the deeptext component, where only pre-trained word embeddings are considered. Of course, as illusttrated in Section 4, you could build your own pre-trained deeptext component and pass it to the WideDeep constructor class, but eventually, I want to allow that option within the package. . This means that eventually I will need to integrate the library with some of the pre-trained Language models available or simply code a custom version for pytorch-widedeep. . One the other hand, if there is one Deep Learning for Tabular data implementation that is becoming more and more popular is TabNet. There is already a fantastic Pytorch implementation which I highly recommend. I believe I could adapt that implementation to pytorch-widedeep and offer it as a deep component or on its own, like any other model component. . I am pretty sure I will think of a few more things along the way. . If you made it this far, thanks for reading! And if you use the package, let me know your thoughts! . References . [1] Universal Language Model Fine-tuning for Text Classification. Jeremy Howard, Sebastian Ruder, 2018 arXiv:1801.06146v5 . [2] Using millions of emoji occurrences to learn any-domain representations for detecting sentiment, emotion and sarcasm. Bjarke Felbo, Alan Mislove, Anders Søgaard, et al., 2017. arXiv:1708.00524 .",
            "url": "https://jrzaurin.github.io/infinitoml/2020/12/11/pytorch-widedeep_ii.html",
            "relUrl": "/2020/12/11/pytorch-widedeep_ii.html",
            "date": " • Dec 11, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "pytorch-widedeep, deep learning for tabular data I: data preprocessing, model components and basic use",
            "content": "This is the first of two posts introducing pytorch-widedeep, which is intended to be a flexible package to use Deep Learning (hereafter DL) with tabular data and combine it with text and images via wide and deep models. pytorch-widedeep is partially based on Heng-Tze Cheng et al., 2016 paper [1]. . in this post I describe the data preprocessing functionalities of the library, the main components of the model, and the basic use of the library. In a second post I will show a more advance use of pytorch-widedeep. . Before I move any further I just want to emphasize that there are a number of libraries that implement functionalities to use DL on tabular data. To cite a few, the ubiquitous and fantastic FastAI (and their tabular api), the &quot;rising star&quot; NVTabular, the powerful pytorch-tabnet based on work of Sercan O. Arik and Tomas Pfisterfrom [2], which is starting to take victories in Kaggle competitions, and perhaps my favourite AutoGluon Tabular [3]. . It is not my intention to &quot;compete&quot; against these libraries. pytorch-widedeep started as an attempt to package and automate an algorithm I had to use a couple of times at work and ended up becoming the entertaining process that is building a library. Needless to say that if you wanted to apply DL to tabular data you should go and check all the libraries I mentioned before (as well as this one 🙂. You can find the source code here)). . 1. Installation . To install the package simply use pip: . pip install pytorch-widedeep . or directly from github . pip install git+https://github.com/jrzaurin/pytorch-widedeep.git . Important note for Mac Users . Note that the following comments are not directly related to the package, but to the interplay between pytorch and OSX (more precisely pytorch&#39;s dependency on OpenMP I believe) and in general parallel processing in Mac. . In the first place, at the time of writing the latest pytorch version is 1.7. This version is known to have some issues when running on Mac and the data-loaders might not run in parallel. . On the other hand, since Python 3.8 the multiprocessing library start method changed from &#39;fork&#39; to &#39;spawn&#39;. This also affects the data-loaders (for any torch version) and they will not run in parallel. . Therefore, for Mac users I suggest using python 3.7 and torch &lt;= 1.6 (with its corresponding torchvision version, i.e. &lt;= 0.7.0). I could have enforced this versioning via the setup.py file. However, there are a number of unknowns and I preferred to leave it as it is. For example I developed the package using macOS Catalina and maybe some of this issues are not present in the new release Big Sur. Also, I hope that they release soon a patch for pytorch 1.7 and some, if not all these problems disappear. . Installing pytorch-widedeep via pip will install the latest version. Therefore, if these problems are present and the dataloaders do not run in parallel, one can easily downgrade manually: . pip install torch==1.6.0 torchvision==0.7.0 . None of these issues affect Linux users . 2. pytorch-widedeep DL Architectures . As I mentioned earlier pytorch-widedeep combines tabular data with text and images via wide and deep models. . With that in mind, the two main architectures that can be built with a few lines of code using pytorch-widedeep are: . . Architecture 1: architecture 1 combines the Wide, linear model with the outputs from the DeepDense or DeepDenseResnet, DeepText and DeepImage components connected to a final output neuron or neurons, depending on whether we are performing a binary classification or regression, or a multi-class classification. The components within the faded-pink rectangles are concatenated. Later in the post I will describe in detail each of the individual components. . In math terms, and following the notation in the paper, Architecture 1 can be formulated as: . $$ preds = sigma(W^{T}_{wide}[x, phi(x)] + W^{T}_{deepdense}a^{(l_f)}_{dense} + W^{T}_{deeptext}a^{(l_f)}_{text} + W^{T}_{deepimage}a^{(l_f)}_{image} + b) $$Where $W$ are the weight matrices applied to the wide model and to the final activations of the deep models, &#39;$a$&#39; are the final activations, and $ phi(x)$ are the cross product transformations of the original features &#39;$x$&#39;. In case you are wondering what are &quot;cross product transformations&quot;, here is a quote taken directly from the paper: &quot;For binary features, a cross-product transformation (e.g., “AND(gender=female, language=en)”) is 1 if and only if the constituent features (“gender=female” and “language=en”) are all 1, and 0 otherwise&quot;. . . Architecture 2: architecture 2 combines the Wide, linear model with the Deep components of the model connected to the output neuron(s), after the different Deep components have been themselves combined through a Fully-Connected-Head (hereafter FC-Head) (that I refer as DeepHead). . In math terms, and following the notation in the paper, Architecture 2 can be formulated as: . $$ preds = sigma(W^{T}_{wide}[x, phi(x)] + W^{T}_{deephead}a^{(l_f)}_{deephead} + b) $$Is important to mention that each individual component, wide, deepdense (either DeepDense or DeepDenseResnet), deeptext and deepimage, can be used independently and in isolation. For example, one could use only wide, which is in simply a linear model. Or use DeepDense which is in essence a similar implementation to that of the Tabular API in the fastai library (which I strongly recommend). . 3. Quick start (TL;DR) . Maybe I should have started with this section, but I thought that knowing at least the architectures one can build with pytorch-widedeep was &quot;kind-off&quot; necessary. In any case and before diving into the details of the library, let&#39;s just say that you just want to quickly run one example and get the feel of how pytorch-widedeep works. Let&#39;s do so using the adult census dataset. . In this example we will be fitting a model comprised by two components: Wide and DeepDense. . #collapse-hide import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score . . #collapse-hide adult = pd.read_csv(&quot;data/adult/adult.csv.zip&quot;) adult.columns = [c.replace(&quot;-&quot;, &quot;_&quot;) for c in adult.columns] adult[&quot;income_label&quot;] = (adult[&quot;income&quot;].apply(lambda x: &quot;&gt;50K&quot; in x)).astype(int) adult.drop(&quot;income&quot;, axis=1, inplace=True) for c in adult.columns: if adult[c].dtype == &#39;O&#39;: adult[c] = adult[c].apply(lambda x: &quot;unknown&quot; if x == &quot;?&quot; else x) adult[c] = adult[c].str.lower() . . adult_train, adult_test = train_test_split(adult, test_size=0.2, stratify=adult.income_label) adult.head() . age workclass fnlwgt education educational_num marital_status occupation relationship race gender capital_gain capital_loss hours_per_week native_country income_label . 0 25 | private | 226802 | 11th | 7 | never-married | machine-op-inspct | own-child | black | male | 0 | 0 | 40 | united-states | 0 | . 1 38 | private | 89814 | hs-grad | 9 | married-civ-spouse | farming-fishing | husband | white | male | 0 | 0 | 50 | united-states | 0 | . 2 28 | local-gov | 336951 | assoc-acdm | 12 | married-civ-spouse | protective-serv | husband | white | male | 0 | 0 | 40 | united-states | 1 | . 3 44 | private | 160323 | some-college | 10 | married-civ-spouse | machine-op-inspct | husband | black | male | 7688 | 0 | 40 | united-states | 1 | . 4 18 | unknown | 103497 | some-college | 10 | never-married | unknown | own-child | white | female | 0 | 0 | 30 | united-states | 0 | . The following lines below is all you need . from pytorch_widedeep.preprocessing import WidePreprocessor, DensePreprocessor from pytorch_widedeep.models import Wide, DeepDense, WideDeep from pytorch_widedeep.metrics import Accuracy # define wide, crossed, embedding and continuous columns, and target wide_cols = [&quot;education&quot;, &quot;relationship&quot;, &quot;workclass&quot;, &quot;occupation&quot;, &quot;native_country&quot;, &quot;gender&quot;] cross_cols = [(&quot;education&quot;, &quot;occupation&quot;), (&quot;native_country&quot;, &quot;occupation&quot;)] embed_cols = [(&quot;education&quot;, 10), (&quot;workclass&quot;, 10), (&quot;occupation&quot;, 10), (&quot;native_country&quot;, 10)] cont_cols = [&quot;age&quot;, &quot;hours_per_week&quot;] target = adult_train[&quot;income_label&quot;].values # prepare wide component preprocess_wide = WidePreprocessor(wide_cols=wide_cols, crossed_cols=cross_cols) X_wide = preprocess_wide.fit_transform(adult_train) wide = Wide(wide_dim=np.unique(X_wide).shape[0], pred_dim=1) # prepare deepdense component preprocess_deep = DensePreprocessor(embed_cols=embed_cols, continuous_cols=cont_cols) X_deep = preprocess_deep.fit_transform(adult_train) deepdense = DeepDense(hidden_layers=[64, 32], deep_column_idx=preprocess_deep.deep_column_idx, embed_input=preprocess_deep.embeddings_input, continuous_cols=cont_cols) # build, compile and fit model = WideDeep(wide=wide, deepdense=deepdense) model.compile(method=&quot;binary&quot;, metrics=[Accuracy]) model.fit(X_wide=X_wide, X_deep=X_deep, target=target, n_epochs=2, batch_size=256) # predict X_wide_te = preprocess_wide.transform(adult_test) X_deep_te = preprocess_deep.transform(adult_test) preds = model.predict(X_wide=X_wide_te, X_deep=X_deep_te) . 0%| | 0/153 [00:00&lt;?, ?it/s] . Training . epoch 1: 100%|██████████| 153/153 [00:03&lt;00:00, 46.74it/s, loss=0.571, metrics={&#39;acc&#39;: 0.7135}] epoch 2: 100%|██████████| 153/153 [00:02&lt;00:00, 51.37it/s, loss=0.395, metrics={&#39;acc&#39;: 0.8159}] predict: 100%|██████████| 39/39 [00:00&lt;00:00, 182.93it/s] . 4. Preprocessors . As you can see in Section 3, and as with any ML algorithm, the data need to be prepared/preprocessed before going through the model. This is handled internally by the pytorch-widedeep preprocessors. There is one preprocessor per WideDeep model component: . WidePreprocessor DensePreprocessor TextPreprocessor ImagePreprocessor . &quot;Behind the scenes&quot;, these preprocessors use a series of helper functions and classes that are in the utils module. Initially I did not intend to &quot;expose&quot; them to the user, but I believe they can be useful for all sorts of preprocessing tasks, so I made them available. The utils tools are: . deep_utils.LabelEncoder text_utils.simple_preprocess text_utils.get_texts text_utils.pad_sequences text_utils.build_embeddings_matrix fastai_transforms.Tokenizer fastai_transforms.Vocab image_utils.SimplePreprocessor image_utils.AspectAwarePreprocessor . They are accessible directly from utils, e.g.: . from pytorch_widedeep.utils import LabelEncoder . Note that here I will be concentrating directly on the preprocessors. If you want more details on the utils tools, have a look to the source code or read the documentation. . 4.1. WidePreprocessor . The Wide component of the model is a linear model that in principle, could be implemented as a linear layer receiving the result of on one-hot encoded categorical columns. However, this is not memory efficient (at all). Therefore, we implement a liner layer as an Embedding layer plus a bias. I will explain it in a bit more detail later. For now, just know that WidePreprocessor simply encodes the categories numerically so that they are the indexes of the lookup table that is an Embedding layer. . from pytorch_widedeep.preprocessing import WidePreprocessor wide_cols = [&#39;education&#39;, &#39;relationship&#39;,&#39;workclass&#39;,&#39;occupation&#39;,&#39;native_country&#39;,&#39;gender&#39;] crossed_cols = [(&#39;education&#39;, &#39;occupation&#39;), (&#39;native_country&#39;, &#39;occupation&#39;)] wide_preprocessor = WidePreprocessor(wide_cols=wide_cols, crossed_cols=crossed_cols) X_wide = wide_preprocessor.fit_transform(adult) # From here on, any new observation can be prepared by simply running `.transform` # new_X_wide = wide_preprocessor.transform(new_df) . X_wide . array([[ 1, 17, 23, ..., 89, 91, 316], [ 2, 18, 23, ..., 89, 92, 317], [ 3, 18, 24, ..., 89, 93, 318], ..., [ 2, 20, 23, ..., 90, 103, 323], [ 2, 17, 23, ..., 89, 103, 323], [ 2, 21, 29, ..., 90, 115, 324]]) . X_wide[0] . array([ 1, 17, 23, 32, 47, 89, 91, 316]) . wide_preprocessor.inverse_transform(X_wide[:1]) . education relationship workclass occupation native_country gender education_occupation native_country_occupation . 0 11th | own-child | private | machine-op-inspct | united-states | male | 11th-machine-op-inspct | united-states-machine-op-inspct | . As we can see, wide_preprocessor numerically encodes the wide_cols and the crossed_cols, which can be recovered using the method inverse_transform. . 4.2 DensePreprocessor . Simply, DensePreprocessor label-encodes the categorical columns and normalizes the numerical ones (unless otherwise specified). . from pytorch_widedeep.preprocessing import DensePreprocessor # cat_embed_cols = [(column_name, embed_dim), ...] cat_embed_cols = [(&#39;education&#39;,10), (&#39;relationship&#39;,8), (&#39;workclass&#39;,10), (&#39;occupation&#39;,10),(&#39;native_country&#39;,10)] continuous_cols = [&quot;age&quot;,&quot;hours_per_week&quot;] deep_preprocessor = DensePreprocessor(embed_cols=cat_embed_cols, continuous_cols=continuous_cols) X_deep = deep_preprocessor.fit_transform(adult) # From here on, any new observation can be prepared by simply running `.transform` # new_X_deep = deep_preprocessor.transform(new_df) . print(X_deep[:5]) . [[ 0. 0. 0. 0. 0. -0.99512893 -0.03408696] [ 1. 1. 0. 1. 0. -0.04694151 0.77292975] [ 2. 1. 1. 2. 0. -0.77631645 -0.03408696] [ 3. 1. 0. 0. 0. 0.39068346 -0.03408696] [ 3. 0. 2. 3. 0. -1.50569139 -0.84110367]] . Behind the scenes, DeepProcessor uses LabelEncoder, simply a custom numerical encoder for categorical features, available via . from pytorch_widedeep.utils import LabelEncoder . 4.3. TextPreprocessor . This preprocessor returns the tokenized, padded sequences that will be directly &quot;fed&quot; to the deeptext component. . To illustrate the text and image preprocessors I will use a small sample of the Airbnb listing dataset, which you can get here. . airbnb=pd.read_csv(&quot;data/airbnb/airbnb_sample.csv&quot;) . texts = airbnb.description.tolist() texts[0] . &#34;My bright double bedroom with a large window has a relaxed feeling! It comfortably fits one or two and is centrally located just two blocks from Finsbury Park. Enjoy great restaurants in the area and easy access to easy transport tubes, trains and buses. Babies and children of all ages are welcome. Hello Everyone, I&#39;m offering my lovely double bedroom in Finsbury Park area (zone 2) for let in a shared apartment. You will share the apartment with me and it is fully furnished with a self catering kitchen. Two people can easily sleep well as the room has a queen size bed. I also have a travel cot for a baby for guest with small children. I will require a deposit up front as a security gesture on both our parts and will be given back to you when you return the keys. I trust anyone who will be responding to this add would treat my home with care and respect . Best Wishes Alina Guest will have access to the self catering kitchen and bathroom. There is the flat is equipped wifi internet,&#34; . from pytorch_widedeep.preprocessing import TextPreprocessor text_preprocessor = TextPreprocessor(text_col=&#39;description&#39;) X_text = text_preprocessor.fit_transform(airbnb) # From here on, any new observation can be prepared by simply running `.transform` # new_X_text = text_preprocessor.transform(new_df) . The vocabulary contains 2192 tokens . print(X_text[0]) . [ 29 48 37 367 818 17 910 17 177 15 122 349 53 879 1174 126 393 40 911 0 23 228 71 819 9 53 55 1380 225 11 18 308 18 1564 10 755 0 942 239 53 55 0 11 36 1013 277 1974 70 62 15 1475 9 943 5 251 5 0 5 0 5 177 53 37 75 11 10 294 726 32 9 42 5 25 12 10 22 12 136 100 145] . TextPreprocessor uses the utilities within the text_utils and the fastai_transforms modules. Again, all the utilities within those modules are are directly accessible from utils, e.g.: . from pytorch_widedeep.utils import simple_preprocess, pad_sequences, build_embeddings_matrix, Tokenizer, Vocab . 4.4 ImagePreprocessor . Finally, ImagePreprocessor simply resizes the images, being aware of the aspect ratio. By default they will be resized to (224, 224, ...). This is because the default deepdense component of the model is a pre-trained ResNet model, which requires inputs of height and width of 224. . Let&#39;s have a look . from pytorch_widedeep.preprocessing import ImagePreprocessor image_preprocessor = ImagePreprocessor(img_col=&#39;id&#39;, img_path=&quot;data/airbnb/property_picture/&quot;) X_images = image_preprocessor.fit_transform(airbnb) # From here on, any new observation can be prepared by simply running `.transform` # new_X_images = image_preprocessor.transform(new_df) . Reading Images from data/airbnb/property_picture/ . 8%|▊ | 79/1001 [00:00&lt;00:02, 394.13it/s] . Resizing . 100%|██████████| 1001/1001 [00:02&lt;00:00, 396.28it/s] . Computing normalisation metrics . X_images[0].shape . (224, 224, 3) . ImagePreprocessor uses two helpers: SimplePreprocessor and AspectAwarePreprocessor, available from the utils module, e.g.: . from pytorch_widedeep.utils import SimplePreprocessor, AspectAwarePreprocessor . These two classes are directly taken from Adrian Rosebrock&#39;s fantastic book &quot;Deep Learning for Computer Vision&quot;. Therefore, all credit to Adrian. . 5. Model Components . Let&#39;s now have a look to the components that can be used to build a wide and deep model. The 5 main components of WideDeep are: . Wide DeepDense or DeepDenseResnet DeepText DeepImage deephead . The first 4 of them will be collected and combined by the WideDeep &quot;collector&quot; class, while the 5th one is optional and added to the WideDeep model through its corresponding parameters: deephead or alternatively head_layers, head_dropout and head_batchnorm . 5.1. Wide . The wide component is a Linear layer &quot;plugged&quot; into the output neuron(s) . The only particularity of our implementation is that we have implemented the linear layer via an Embedding layer plus a bias. While the implementations are equivalent, the latter is faster and far more memory efficient, since we do not need to one hot encode the categorical features. . Let&#39;s have a look: . import torch import pandas as pd import numpy as np from torch import nn . df = pd.DataFrame({&#39;color&#39;: [&#39;r&#39;, &#39;b&#39;, &#39;g&#39;], &#39;size&#39;: [&#39;s&#39;, &#39;n&#39;, &#39;l&#39;]}) df.head() . color size . 0 r | s | . 1 b | n | . 2 g | l | . one hot encoded, the first observation (color: r, size: s) would be . obs_0_oh = (np.array([1., 0., 0., 1., 0., 0.])).astype(&#39;float32&#39;) . if we simply numerically encode (or label encode) the values: . obs_0_le = (np.array([0, 3])).astype(&#39;int64&#39;) . Note that in the implementation of the package we start from 1, saving 0 for padding, i.e. unseen values. . Now, let&#39;s see if the two implementations are equivalent . # we have 6 different values. Let&#39;s assume we are performing a regression, so pred_dim = 1 lin = nn.Linear(6, 1) . emb = nn.Embedding(6, 1) emb.weight = nn.Parameter(lin.weight.reshape_as(emb.weight)) . lin(torch.tensor(obs_0_oh)) . tensor([0.0875], grad_fn=&lt;AddBackward0&gt;) . emb(torch.tensor(obs_0_le)).sum() + lin.bias . tensor([0.0875], grad_fn=&lt;AddBackward0&gt;) . And this is precisely how the linear component Wide is implemented . from pytorch_widedeep.models import Wide wide = Wide(wide_dim=10, pred_dim=1) wide . Wide( (wide_linear): Embedding(11, 1, padding_idx=0) ) . Again, let me emphasize that even though the input dim is 10, the Embedding layer has 11 weights. This is because we save 0 for padding, which is used for unseen values during the encoding process . 5.2. DeepDense and DeepDenseResnet . There are two alternatives for the so called deepdense component of the model: DeepDense and DeepDenseResnet. . DeepDense is comprised by a stack of dense layers that receive the embedding representation of the categorical features concatenated with numerical continuous features (normalized unless otherwise specified). For those familiar with the Fastai&#39;s tabular API, DeepDense is almost identical to their tabular model. . DeepDenseResnet is similar to DeepDense but instead of dense layers, the embedding representation of the categorical features concatenated with numerical continuous features are passed through a series of dense ResNet layers. Each basic block comprises the following operations: . . Let&#39;s have a look first to DeepDense: . from pytorch_widedeep.models import DeepDense # fake dataset X_deep = torch.cat((torch.empty(5, 4).random_(4), torch.rand(5, 1)), axis=1) colnames = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] embed_input = [(u,i,j) for u,i,j in zip(colnames[:4], [4]*4, [8]*4)] deep_column_idx = {k:v for v,k in enumerate(colnames)} continuous_cols = [&#39;e&#39;] # my advice would be to not use dropout in the last layer, but I add the option because you never # know..there is crazy people everywhere. deepdense = DeepDense(hidden_layers=[16,8], dropout=[0.5, 0.], batchnorm=True, deep_column_idx=deep_column_idx, embed_input=embed_input, continuous_cols=continuous_cols) deepdense . DeepDense( (embed_layers): ModuleDict( (emb_layer_a): Embedding(4, 8) (emb_layer_b): Embedding(4, 8) (emb_layer_c): Embedding(4, 8) (emb_layer_d): Embedding(4, 8) ) (embed_dropout): Dropout(p=0.0, inplace=False) (dense): Sequential( (dense_layer_0): Sequential( (0): Linear(in_features=33, out_features=16, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): BatchNorm1d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): Dropout(p=0.5, inplace=False) ) (dense_layer_1): Sequential( (0): Linear(in_features=16, out_features=8, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): BatchNorm1d(8, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): Dropout(p=0.0, inplace=False) ) ) ) . deepdense(X_deep) . tensor([[ 1.5131, -0.2351, 1.9998, 1.9794, -0.7550, -0.7819, -0.5403, -0.7078], [-1.0226, -0.1453, -0.4958, -0.5826, 1.7906, 1.1094, 1.6101, 0.1329], [-1.0305, -1.3890, -0.4859, -0.5942, 0.4141, -0.8311, -0.9921, -0.5953], [-0.2079, 1.7296, -0.5191, -0.5849, -0.7293, -0.8299, 0.7122, -0.7265], [ 0.7479, 0.0398, -0.4990, -0.2177, -0.7204, 1.3335, -0.7899, 1.8967]], grad_fn=&lt;NativeBatchNormBackward&gt;) . Let&#39;s now have a look to DeepDenseResnet: . from pytorch_widedeep.models import DeepDenseResnet deepdense = DeepDenseResnet(blocks=[16,8], dropout=0.5, deep_column_idx=deep_column_idx, embed_input=embed_input, continuous_cols=continuous_cols) deepdense . DeepDenseResnet( (embed_layers): ModuleDict( (emb_layer_a): Embedding(4, 8) (emb_layer_b): Embedding(4, 8) (emb_layer_c): Embedding(4, 8) (emb_layer_d): Embedding(4, 8) ) (embed_dropout): Dropout(p=0.0, inplace=False) (dense_resnet): Sequential( (lin1): Linear(in_features=33, out_features=16, bias=True) (bn1): BatchNorm1d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (block_0): BasicBlock( (lin1): Linear(in_features=16, out_features=8, bias=True) (bn1): BatchNorm1d(8, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (leaky_relu): LeakyReLU(negative_slope=0.01, inplace=True) (dp): Dropout(p=0.5, inplace=False) (lin2): Linear(in_features=8, out_features=8, bias=True) (bn2): BatchNorm1d(8, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (resize): Sequential( (0): Linear(in_features=16, out_features=8, bias=True) (1): BatchNorm1d(8, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) ) ) ) . deepdense(X_deep) . tensor([[-1.0085e-02, 1.0810e+00, -9.7679e-03, -1.1307e-02, 4.4197e-01, 5.4999e-01, -4.2809e-03, -1.1828e-02], [ 1.9041e+00, -1.1581e-02, 1.8792e+00, 7.7701e-01, 5.2448e-01, -5.5533e-03, 1.6126e+00, 1.5220e+00], [ 1.2326e+00, -1.6174e-03, 1.1446e+00, 1.6528e+00, -1.5239e-02, -8.0476e-03, 3.3760e-02, 1.1949e+00], [-2.9320e-02, 8.9202e-01, 9.6470e-01, -1.9520e-02, -2.7348e-03, 3.3712e+00, 6.0935e-01, 5.4437e-01], [ 8.0375e-01, -6.5314e-03, -3.0117e-02, 6.5286e-01, 8.3092e-01, -2.5611e-02, -1.8277e-02, -2.0785e-02]], grad_fn=&lt;LeakyReluBackward1&gt;) . 5.3. DeepText . The DeepText class within the WideDeep package is a standard and simple stack of LSTMs on top of word embeddings. You could also add a FC-Head on top of the LSTMs. The word embeddings can be pre-trained. . In the future I aim to include full pre-trained models (maybe bringing the huggingface library, ULMFiT [5] or SHA-RNN) [4] so that the combination between text and images is &quot;fair&quot; (since for the image model one can choose full pre-trained models, as we will see in the next sub-section). . On the other hand, while I recommend using the Wide and DeepDense classes within pytorch-widedeep when building the corresponding model components, it is very likely that the user will want to use custom text and image models. That is perfectly possible. Simply, build them and pass them as the corresponding parameters. Note that the custom models MUST return a last layer of activations (i.e. not the final prediction) so that these activations are collected by WideDeep and combined accordingly. In addition, the models MUST also contain an attribute output_dim with the size of these last layers of activations. . I will illustrate all of the above more in detail in the second post of these series. . Let&#39;s have a look to DeepText . import torch from pytorch_widedeep.models import DeepText . X_text = torch.cat((torch.zeros([5,1]), torch.empty(5, 4).random_(1,4)), axis=1) deeptext = DeepText(vocab_size=4, hidden_dim=4, n_layers=1, padding_idx=0, embed_dim=4) deeptext . DeepText( (word_embed): Embedding(4, 4, padding_idx=0) (rnn): LSTM(4, 4, batch_first=True) ) . deeptext(X_text) . tensor([[ 0.3217, 0.0459, 0.2314, 0.2049], [ 0.0146, 0.0818, -0.3678, 0.2232], [-0.0175, 0.1433, -0.3312, 0.2409], [ 0.0154, 0.1384, -0.3101, 0.2398], [ 0.1574, 0.0884, -0.2047, 0.2322]], grad_fn=&lt;SelectBackward&gt;) . You could, if you wanted, add a Fully Connected Head (FC-Head) on top of it . deeptext = DeepText(vocab_size=4, hidden_dim=8, n_layers=1, padding_idx=0, embed_dim=4, head_layers=[8,4], head_batchnorm=True, head_dropout=[0.5, 0.5]) . deeptext . DeepText( (word_embed): Embedding(4, 4, padding_idx=0) (rnn): LSTM(4, 8, batch_first=True) (texthead): Sequential( (dense_layer_0): Sequential( (0): Linear(in_features=8, out_features=4, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): BatchNorm1d(4, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): Dropout(p=0.5, inplace=False) ) ) ) . deeptext(X_text) . tensor([[ 0.2332, -0.0000, 0.0000, 3.3695], [-0.0000, 0.2724, -0.0000, -0.0000], [ 0.0000, -0.0000, -1.1019, -0.0000], [-0.0000, 0.0640, -0.0000, -0.7391], [ 0.0000, -0.0000, -0.0000, 0.0000]], grad_fn=&lt;MulBackward0&gt;) . 5.4. DeepImage . The DeepImage class within the WideDeep package builds either a pre-trained ResNet (18, 34, or 50. Default is 18) or a stack of CNNs, to which one can add a FC-Head. If is a pre-trained ResNet, you can chose how many layers you want to defrost deep into the network with the parameter freeze. Read here for more details. . from pytorch_widedeep.models import DeepImage X_img = torch.rand((2,3,224,224)) deepimage = DeepImage(pretrained=False, head_layers=[512, 64, 8]) deepimage . DeepImage( (backbone): Sequential( (0): Sequential( (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): BatchNorm2d(64, eps=1e-05, momentum=0.01, affine=True, track_running_stats=True) (2): LeakyReLU(negative_slope=0.1, inplace=True) (maxpool): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False) ) (1): Sequential( (0): Conv2d(64, 128, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(128, eps=1e-05, momentum=0.01, affine=True, track_running_stats=True) (2): LeakyReLU(negative_slope=0.1, inplace=True) ) (2): Sequential( (0): Conv2d(128, 256, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(256, eps=1e-05, momentum=0.01, affine=True, track_running_stats=True) (2): LeakyReLU(negative_slope=0.1, inplace=True) ) (3): Sequential( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(512, eps=1e-05, momentum=0.01, affine=True, track_running_stats=True) (2): LeakyReLU(negative_slope=0.1, inplace=True) (adaptiveavgpool): AdaptiveAvgPool2d(output_size=(1, 1)) ) ) (imagehead): Sequential( (dense_layer_0): Sequential( (0): Linear(in_features=512, out_features=64, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): Dropout(p=0.0, inplace=False) ) (dense_layer_1): Sequential( (0): Linear(in_features=64, out_features=8, bias=True) (1): LeakyReLU(negative_slope=0.01, inplace=True) (2): Dropout(p=0.0, inplace=False) ) ) ) . deepimage(X_img) . tensor([[ 0.2624, -0.0012, 0.1050, -0.0005, -0.0006, 0.1206, -0.0026, 0.0511], [ 0.2639, -0.0012, 0.1068, -0.0005, -0.0006, 0.1228, -0.0026, 0.0504]], grad_fn=&lt;LeakyReluBackward1&gt;) . 5.5. deephead . Note that I do not use uppercase here. This is because, by default, the deephead is not necessarily defined outside WideDeep as a class on its own, like the the rest of the components. . When defining the WideDeep model there is a parameter called head_layers (and the corresponding head_dropout, and head_batchnorm) that define the FC-head on top of DeeDense, DeepText and DeepImage. . Of course, you could also chose to define it yourself externally and pass it using the parameter deephead. Have a look at the documentation. . 6. Conclusion . This is the first of 2 posts introducing the python library pytorch-widedeep. This library is intended to be a flexible frame to combine tabular data with text and images via wide and deep models. Of course, it can also be used directly on &quot;traditional&quot; tabular data, without text and/or images, as we saw in Section 3. . In this post I have shown how to quickly start using the library (Section 3) and explained the utilities available in the preprocessing module (Section 4) and and model component definitions (Section 5), available in the models module. . In the next post I will show more advance uses that hopefully will illustrate pytorch-widedeep&#39;s flexibility to build wide and deep models. . References . [1] Wide &amp; Deep Learning for Recommender Systems. Heng-Tze Cheng, Levent Koc, Jeremiah Harmsen, et al. 2016. arXiv:1606.07792 . [2] TabNet: Attentive Interpretable Tabular Learning. Sercan O. Arik, Tomas Pfister, 2020. arXiv:1908.07442 . [3] AutoGluon-Tabular: Robust and Accurate AutoML for Structured Data Nick Erickson, Jonas Mueller, Alexander Shirkov, et al., 2020. arXiv:2003.06505 . [4] Universal Language Model Fine-tuning for Text Classification. Jeremy Howard, Sebastian Ruder, 2018 arXiv:1801.06146v5 . [5] Single Headed Attention RNN: Stop Thinking With Your Head. Stephen Merity, 2019 arXiv:1801.06146v5 .",
            "url": "https://jrzaurin.github.io/infinitoml/2020/12/06/pytorch-widedeep.html",
            "relUrl": "/2020/12/06/pytorch-widedeep.html",
            "date": " • Dec 6, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "RecoTour III: Variational Autoencoders for Collaborative Filtering with Mxnet and Pytorch",
            "content": "This post and the code here are part of a larger repo called RecoTour, where I normally explore and implement some recommendation algorithms that I consider interesting and/or useful (see RecoTour and RecoTourII). In every directory, I have included a README file and a series of explanatory notebooks that I hope help explaining the code. I keep adding algorithms from time to time, so stay tunned if you are interested. . As always, let me first acknowledge the relevant people that did the hard work. This post and the companion repo are based on the papers “Variational Autoencoders for Collaborative Filtering” [1] and &quot;Auto-Encoding Variational Bayes&quot; [2]. The code here and in that repo is partially inspired by the implementation from Younggyo Seo. I have adapted the code to my coding preferences and added a number of options and flexibility to run multiple experiment. . The reason to take a deep dive into variational autoencoders for collaborative filtering is because they seem to be one of the few Deep Learning based algorithm (if not the only one) that is obtains better results that those using non-Deep Learning techniques [3]. . All the experiments in this post were run using a p2.xlarge EC2 instance on AWS. . 1. Variational Autoencoders for collaborative filtering . I must admit that when it comes to variational autoencoders (VAEs) I find that there is a &quot;notable&quot; difference between the complexity of the math and that of the code (or maybe is just me that I am not a mathematician). Nonetheless, I think that speaking about VAEs and not mentioning log likelihoods, Evidence Lower Bound (EBLO) or the Kullback–Leibler divergence ($ text{D}_{ text{KL}}$) is almost like &quot;cheating&quot;. With that in mind I will try to give some mathematical context to &quot;Partially Regularized Multinomial Variational Autoencoder&quot; ($ text{Mult-VAE}^{ text{PR}}$) for collaborative filtering and then move to the code. The whole purpose of the math below is to ultimately justify the loss function we will be using when training the $ text{Mult-VAE}^{ text{PR}}$ as well as the architecture of the algorithm. . Before diving into the problem scenario and the mathematical formulation, let me describe the notational convention. Following Liang et al., 2018, I will use $u in {1, dots,U }$ to index users and $i in {1, dots,I }$ to index items. The user-by-item binary interaction matrix (i.e. the click matrix) is $ mathbf{X} in mathbb{N}^{U times I}$ and I will use lower case $ mathbf{x}_u =[X_{u1}, dots,X_{uI}]^ top in mathbb{N}^I$ to refer to the click history of an individual user $u$. . 1.1 Problem scenario . We are given a dataset $ mathbf{X} = { { mathbf{x}_u} }^{U}_{u=1}$ of user clicks (a more general scenario is described in &quot;Auto-Encoding Variational Bayes&quot; [2]). Our job is to estimate the parameters of the underlying probability distribution so that we can do inference. In other words, we need to find a statistical model of the data (like in any other ML problem). To do this, we need to maximize the likelihood function $p_{ theta}( mathbf{X})$ so that under the assumed statistical model the observed data is most probable. . To find the maximum likelihood we could assume that the statistical model of the data involves some latent variable $ bf{z}$, so that the marginal likelihood can be written as: . $$ p_{ theta}( mathbf{x}_u) = int {p_{ theta}( mathbf{z}_u)p_{ theta}( mathbf{x}_u vert mathbf{z}_u) d mathbf{z}_u} hspace{1cm} (1) $$where $ theta$ are the parameters of the distribution. Eq (1) is solvable if we assume that both the prior $p_{ theta}( mathbf{z}_u)$ and the conditional probability $p_{ theta}( mathbf{x}_u vert mathbf{z}_u)$ come from parametric families of distributions and that their PDFs are differentiable almost everywhere w.r.t. both $ theta$ and $ mathbf{z}_u$. However, for &quot;moderately&quot; complicated likelihood functions $p_{ theta}( mathbf{x}_u vert mathbf{z}_u)$, such as a neural network with a nonlinear layer, Eq (1) is intractable (it is not possible to evaluate of differentiate the marginal likelihood). Furthermore, the true posterior $p_{ theta}( mathbf{z}_u vert mathbf{x}_u) = p_{ theta}( mathbf{x}_u vert mathbf{z}_u)p_{ theta}( mathbf{z}_u)/p_{ theta}( mathbf{x}_u)$ is also intractable, and therefore we cannot use an EM algorithm (since the E-step involves the computation of the true posterior at a given iteration). . To address these and some other limitations, and find a general solution to this problem, Kingma and Welling 2014 proposed a flexible neural network based approach. . 1.2 Auto-Encoding Variational Bayes . The following Section is both a summary and my understanding of the paper &quot;Auto-Encoding Variational Bayes&quot; to which I keep referring and that I strongly recommend reading. . Let me remind you: our goal is to maximize the likelihood, or more conveniently the log likelihood $ log p_{ theta}( mathbf{X})$, where: . $$ log p_{ theta}( mathbf{X}) = sum_u log p_{ theta}( mathbf{x}_u) hspace{1cm} (2) $$Each term in the summation can be re-written as: . $$ log p_{ theta}( mathbf{x}_u) = D_{KL} left(q_ phi( textbf{z}_u vert textbf{x}_u) | p_ theta( textbf{z}_u vert textbf{x}_u) right) + underbrace{ mathbb{E} small{ q_{ phi}( mathbf{z}_u vert mathbf{x}_u) } left[ - log q_{ phi}( mathbf{z}_u vert mathbf{x_u}) + log p_{ theta}( mathbf{x}_u, mathbf{z}_u) right]}_{ELBO mathcal L( textbf{x}_u, phi, theta)} hspace{1cm} (3) $$Where the first elements in the right hand side is the Kullback–Leibler divergence ($ text{D}_{ text{KL}}$) and $q_ phi( textbf{z}_u vert textbf{x}_u)$ is the approximate posterior of the true posterior $p_ theta( textbf{z}_u vert textbf{x}_u)$. Eq (3) is our &quot;point of entry&quot; from which we will derive the remaining equations. If you want proof of Eq (3) I would recommend reading this tutorial or this &quot;crazy&quot; post. . Moving on, given that $ text{D}_{ text{KL}}$ is non-negative, $ log p_{ theta}( mathbf{x}_u) geq mathcal L( textbf{x}_u, phi, theta)$ and therefore $ mathcal L$ is referred as Evidence Lower Bound (ELBO). It is straightforward to understand from Eq (3) that maximizing $ log p_{ theta}( mathbf{x}_u)$ implies maximizing ELBO $ mathcal L$. If we re-order the terms in that equation, we could also think of the problem as follows: maximizing ELBO $ mathcal L$ implies minimizing $ text{D}_{ text{KL}}$, which makes sense, since $D_{KL}$ measures the dissimilarity between the approximate posterior $q_ phi( textbf{z}_u vert textbf{x}_u)$ and the true posterior $p_{ theta}( textbf{z}_u vert textbf{x}_u)$. . ELBO $ mathcal L$ in Eq (3) can also be re-written as: . $$ mathcal L( textbf{x}_u, phi, theta) = - D_{KL} left(q_ phi( textbf{z}_u vert textbf{x}_u) | p_ theta( textbf{z}_u right) + mathbb{E} small{ q_{ phi}( mathbf{z}_u vert mathbf{x}_u) } left[ log p_{ theta}( textbf{x}_u vert textbf{z}_u) right] hspace{1cm} (4) $$We can see that Eq (4) involves sampling $ tilde{ mathbf{z}_u} sim q_{ phi}( mathbf{z}_u vert mathbf{x}_u)$. When sampling is involved, backpropagation is not trivial (how one would take gradients with respect to $ phi$?). To remedy this situation Kingma &amp; Welling introduced the so called &quot;reparameterization trick&quot;. Instead of sampling from the approximate postertior $q_{ phi}( mathbf{z}_u vert mathbf{x}_u)$, the authors used a differentiable transformation $g_{ phi}( mathbf{ epsilon}, mathbf{x}_u)$ of a noise variable $ epsilon$, such that: . $$ tilde{ mathbf{z}_u} = g_{ phi}( mathbf{ epsilon}, mathbf{x}_u) hspace{1cm} with hspace{1cm} mathbf{ epsilon} sim p( epsilon) hspace{1cm} (5) $$where $p( epsilon)$ can be, for example, a variable sampled from a random normal distribution (see Section 1.3 for the selection of $g_{ phi}$ in the particular case of the $ text{Mult-VAE}^{ text{PR}}$). With these formulation, one can use Monte Carlo estimates of expectations of some function $f( mathbf{z})$ with respect to $q_{ phi}( mathbf{z}_u vert mathbf{x}_u)$ such that: . $$ mathbb{E} small{ q_{ phi}( mathbf{z}_u vert mathbf{x}_u) } left[ f( mathbf{z}_u) right] = mathbb{E} small{ q_{ phi}( mathbf{z}_u vert mathbf{x}_u) } left[ f(g_{ phi}( mathbf{ epsilon}, mathbf{x}_u)) right] simeq frac{1}{L} sum_{l=1}^{L} f(g_{ phi}( mathbf{ epsilon}^l), mathbf{x}_u) text{where} hspace{1cm} mathbf{ epsilon}^l sim p( epsilon) hspace{1cm} (6) $$Replacing the second term in Eq (4) with the result in Eq (6), we see that the ELBO $ mathcal L$ can be approximated by what Kingma and Welling called &quot;Generic Stochastic Gradient Variational Bayes&quot; (SGVB) estimator $ tilde{ mathcal L}( textbf{x}_u, phi, theta) simeq mathcal L( textbf{x}_u, phi, theta)$: . $$ tilde{ mathcal L}( mathbf{x}_u, phi, theta) = - D_{KL} left(q_ phi( textbf{z}_u vert textbf{x}_u) | p_ theta( textbf{z}_u right) + frac{1}{L} sum_{l=1}^{L} log p_{ theta}( mathbf{x}_u vert mathbf{z}^l_u) text{where} hspace{1cm} mathbf{z}^l_u = g_{ phi}( epsilon^l_u, mathbf{x}_u) hspace{1cm} text{and} hspace{1cm} epsilon^l sim p( epsilon) hspace{1cm} (7) $$Of course, when running a practical application, we will be using minibatches. With that in mind, we can re-write ELBO $ mathcal{L}$ in &quot;minibatch form&quot; as: . $$ mathcal L( mathbf{ text{X}}^M, phi, theta) simeq tilde{ mathcal L}^{M}( mathbf{ text{X}}^M, phi, theta) = frac{1}{M} sum_{u=1}^{M} tilde{ mathcal L}( mathbf{x}_u, phi, theta) hspace{1cm} (8) $$where $ mathbf{X}^M = { mathbf{x}_u }_{u=1}^M$ is a minibatch of M users. In their experiments the authors found that the number of samples $L$ can be set to 1 as long as the minibatch size was large enough, e.g. $M$ = 100. Therefore, as long as our batch sizes are of 100 or more, Eq (7) can be re-written as: . $$ mathcal L( mathbf{ text{X}}^M, phi, theta) simeq frac{1}{M} sum_{u=1}^{M} - D_{KL} left(q_ phi( textbf{z}_u vert textbf{x}_u) | p_ theta( textbf{z}_u right) + log p_{ theta}( mathbf{x}_u vert mathbf{z}^s_u) hspace{1cm} (9) $$Note that $ mathbf{z}^s_u$ signifies that $ mathbf{z}_u$ still needs to be sampled once from $q_ phi( textbf{z}_u vert textbf{x}_u)$, but using the reparameterization trick this will be rather easy, as we will see in the next section. Finally, now that we have a &quot;nice looking&quot; mathematical expression, this is how Auto-Encoding Variational Bayes works: . Select a prior for latent representation of $ textbf{x}_u$, $p_{ theta}( textbf{z}_u)$ | Use a neural network to parameterize the distribution $p_{ theta}( textbf{x}_u vert textbf{z}_u)$. Because this part of the model maps the latent variable/representation $ textbf{z}_u$ to the observed data $ textbf{x}_u$, it is referred as a &quot;decoder&quot; network. | Rather than explicitly calculating the intractable posterior $p_{ theta}( textbf{z}_u vert textbf{x}_u)$, use another another neural network to parameterize the distribution $q_ phi( textbf{z}_u vert textbf{x}_u)$ as the approximate posterior. Since $q_ phi$ maps the observed data $ textbf{x}_u$ to the latent space of $ textbf{z}_u$&#39;s, is referred as the &quot;encoder&quot; network. | maxmize ELBO $ mathcal{L}$ in Eq (9) using Stochastic Gradient Descent or any of its cousins | 1.3 Partially Regularized Autoencoder for Collaborative Filtering . or $ text{Mult-VAE}^{ text{PR}}$... . In the previous Section we obtained Eq (9), which is a generic form of the function we need to maximize to solve the problem described in Section 1.1. Now let&#39;s see a particular case of that equation for the set up used by Liang and co-authors in their paper. Such set up is described as follows: for each user $u$, the latent representation $ textbf{z}_u$ is assumed to be drawn from a standard Gaussian prior $p( textbf{z}_u) sim mathcal N(0, I)$. Such representation is then transformed by a multi-layer perceptron (MLP), and the output is normalized via a Softmax function to produce a probability distribution over all items $I$, $ pi( mathbf{z}_u) = Softmax(MLP( mathbf{z}_u))$. Then, the click history of user $u$ is assumed to be drawn from a Multinomial distribution with probability $ pi( mathbf{z}_u)$: . $$ textbf{x}_u sim text{Mult}(N_u, pi( mathbf{z}_u)) hspace{1cm} (10) $$where $N_u = sum_i x_{ui}$ is the total number of clicks for user $u$. In this set up, the log-likelihood of the click history $ mathbf{x}_u$ conditioned to the latent representation $ mathbf{z}_u$ is simply: . $$ begin{equation*} log(p_{ theta}( textbf{x}_u vert textbf{z}_u)) = mathbf{x}_u log( pi( mathbf{z}_u)) hspace{1cm} (11) end{equation*} $$The posterior $q_ phi( textbf{z}_u vert textbf{x}_u)$ is also chosen to be a standard Gaussian $q_ phi( textbf{z}_u vert textbf{x}_u) sim mathcal N( mu_ phi( textbf{x}_u), sigma_ phi( textbf{x}_u) I)$ where $ mu_ phi( textbf{x}_u)$ and $ sigma_ phi( textbf{x}_u)$ are functions implemented as neural networks. Then, we use the reparameterization trick and chose $g_{ phi}( mathbf{ epsilon}, mathbf{x}_u) = mu( textbf{x}_u) + sigma( textbf{x}_u) cdot epsilon$, where $ epsilon sim mathcal{N}(0,I)$. This way $ mathbf{z}^s_u = mu( textbf{x}_u) + sigma( textbf{x}_u) cdot epsilon$ where we sample directly $ epsilon$. . At this stage we have defined the Gaussian prior, the Gaussian approximate posterior and our sampled latent representation. We are finally ready to &quot;plug the terms&quot; into Eq (9) and write the loss function that we will minimize when training the Mult-VAE: . $$ Loss = - frac{1}{M} sum_{u=1}^{M} left[ mathbf{x}_u log( pi( mathbf{z}_u)) + frac{ beta}{2} sum_j ( 1 + log( sigma_{uj}^2) - mu_{uj}^2 - sigma_{uj}^2 ) right] hspace{1cm} (12) $$Note that the expression above is the negative ELBO $ mathcal L$ (maximizing $ mathcal L$ is equivalent to minimize -$ mathcal L$) with a multiplicative factor $ beta$ applied to the $D_{KL}$. For the math behind the $D_{KL}$ expression given this set up have a look here. . Let me just comment on that $ beta$. Looking at the loss function in Eq (12) within the context of VAEs, we can see that the first term is the reconstruction loss, while the $D_{KL}$ act as a regularizer. With that in mind, Liang et al add a factor $ beta$ to control the strength of the regularization, and propose $ beta &lt; 1$. . Let&#39;s pause for one second and think on what this means. First of all, we are no longer optimizing a lower bound for a given log likelihood. In addition, remember that the $D_{KL}$ divergence measures the similarity between the approximate posterior $q_ phi( textbf{z}_u vert textbf{x}_u)$ and the prior $p_ theta( textbf{z}_u)$. Therefore, by using $ beta &lt; 1$ we are weakening the influence of the prior constrain $q_ phi( textbf{z}_u vert textbf{x}_u) approx p_ theta( textbf{z}_u)$ on the loss. This means that we are less able to generalize to novel user clicks from historical data. However, when building recommendation systems we are often not interested in reproducing precisely click histories (i.e. achieving the best loss) but in making good recommendations (i.e. achieving the best ranking metrics). As the authors show in the paper (and we will see here later), the best ranking metrics are obtained when using $ beta &lt; 1$ and in consequence they name the algorithm Partially Regularized Multinomial Autoencoder or $ text{Mult-VAE}^{ text{PR}}$. . 2. Preparing the data . Throughout this exercise I will use two dataset. The Amazon Movies and TV dataset [4] [5] and the Movilens dataset. The later is used so I can make sure I am obtaining consistent results to those obtained in the paper. As we will see through the notebook, the Amazon dataset is significantly more challenging that the Movielens dataset. . The data preparation is fairly simple, and is identical for both datasets. Therefore, I will focus here only on the Amazon dataset. . #collapse-hide import os import sys import pandas as pd import numpy as np import pickle from tqdm import trange from typing import Tuple, Dict, Union from pathlib import Path sys.path.append(os.path.abspath(&#39;/Users/javier/ml_experiments_python/RecoTour/Amazon/mult-vae/&#39;)) rootpath = Path(&quot;/Users/javier/ml_experiments_python/RecoTour/Amazon/mult-vae/&quot;) . . DATA_DIR = Path(rootpath / &#39;data&#39;) new_colnames = [&quot;user&quot;, &quot;item&quot;, &quot;rating&quot;, &quot;timestamp&quot;] inp_path = DATA_DIR / &quot;amazon-movies&quot; filename = &quot;reviews_Movies_and_TV_5.p&quot; raw_data = pd.read_pickle(inp_path / filename) keep_cols = [&quot;reviewerID&quot;, &quot;asin&quot;, &quot;overall&quot;, &quot;unixReviewTime&quot;] raw_data = raw_data[keep_cols] raw_data.columns = new_colnames . print(raw_data.shape) raw_data.head() . (1697533, 4) . user item rating timestamp . 0 ADZPIG9QOCDG5 | 0005019281 | 4 | 1203984000 | . 1 A35947ZP82G7JH | 0005019281 | 3 | 1388361600 | . 2 A3UORV8A9D5L2E | 0005019281 | 3 | 1388361600 | . 3 A1VKW06X1O2X7V | 0005019281 | 5 | 1202860800 | . 4 A3R27T4HADWFFJ | 0005019281 | 4 | 1387670400 | . 2.1 Filter triples (user, item, score) . The first thing that the we do is to &quot;filter triples&quot; (hereafter refereed as tp) based on the number of times a user interacted with items (min_user_click) or items that where &quot;interacted with&quot; by a user a given number of times (min_item_click). . def get_count(tp: pd.DataFrame, id: str) -&gt; pd.Index: &quot;&quot;&quot; Returns `tp` groupby+count by `id` &quot;&quot;&quot; playcount_groupbyid = tp[[id]].groupby(id, as_index=False) count = playcount_groupbyid.size() return count def filter_triplets( tp: pd.DataFrame, min_user_click, min_item_click ) -&gt; Tuple[pd.DataFrame, pd.Index, pd.Index]: &quot;&quot;&quot; Returns triplets (`tp`) of user-item-rating for users/items with more than min_user_click/min_item_click counts &quot;&quot;&quot; if min_item_click &gt; 0: itemcount = get_count(tp, &quot;item&quot;) tp = tp[tp[&quot;item&quot;].isin(itemcount.index[itemcount &gt;= min_item_click])] if min_user_click &gt; 0: usercount = get_count(tp, &quot;user&quot;) tp = tp[tp[&quot;user&quot;].isin(usercount.index[usercount &gt;= min_user_click])] usercount, itemcount = get_count(tp, &quot;user&quot;), get_count(tp, &quot;item&quot;) return tp, usercount, itemcount . filtered_raw_data, user_activity, item_popularity = filter_triplets( raw_data, min_user_click=5, min_item_click=0 ) . Note that, since I am using the &quot;reviews_Movies_and_TV_5&quot; (i.e. the 5-core dataset, where users and items have at least 5 reviews each) filtered_raw_data has no effect on the Amazon dataset. It does however filter some users/items in the case of the Movilens dataset. . Let&#39;s now have a look to the sparsity of the dataset: . sparsity = ( 1.0 * filtered_raw_data.shape[0] / (user_activity.shape[0] * item_popularity.shape[0]) ) print( &quot;After filtering, there are %d watching events from %d users and %d movies (sparsity: %.3f%%)&quot; % ( filtered_raw_data.shape[0], user_activity.shape[0], item_popularity.shape[0], sparsity * 100, ) ) . After filtering, there are 1697533 watching events from 123960 users and 50052 movies (sparsity: 0.027%) . Comparing these numbers to those of the Movilens dataset (9990682 watching events from 136677 users and 20720 movies: sparsity: 0.353%. see the notebook corresponding to the original publication, or the original publication itself) one can see that the Amazon dataset is $ sim$13 times more sparse than the Movielens dataset. In consequence, I one would expect that the algorithm finds it more challenging, resulting in lower ranking metrics. . 2.2 Train, validation and test split . Once the raw data is filtered, we follow the same procedure than that of the original paper to split the users into training, validation and test users. . def split_users( unique_uid: pd.Index, test_users_size: Union[float, int] ) -&gt; Tuple[pd.Index, pd.Index, pd.Index]: n_users = unique_uid.size if isinstance(test_users_size, int): n_heldout_users = test_users_size else: n_heldout_users = int(test_users_size * n_users) tr_users = unique_uid[: (n_users - n_heldout_users * 2)] vd_users = unique_uid[(n_users - n_heldout_users * 2) : (n_users - n_heldout_users)] te_users = unique_uid[(n_users - n_heldout_users) :] return tr_users, vd_users, te_users . unique_uid = user_activity.index np.random.seed(98765) idx_perm = np.random.permutation(unique_uid.size) unique_uid = unique_uid[idx_perm] tr_users, vd_users, te_users = split_users( unique_uid, test_users_size=0.1 ) print(tr_users.shape, vd_users.shape, te_users.shape) . (99168,) (12396,) (12396,) . And this is how the authors set up the experiment: for validation and test they consider &quot;only&quot; items that have been seen during training . # Select the training observations raw data tr_obsrv = filtered_raw_data.loc[filtered_raw_data[&quot;user&quot;].isin(tr_users)] tr_items = pd.unique(tr_obsrv[&quot;item&quot;]) # Save index dictionaries to &quot;numerise&quot; later one item2id = dict((sid, i) for (i, sid) in enumerate(tr_items)) user2id = dict((pid, i) for (i, pid) in enumerate(unique_uid)) vd_obsrv = filtered_raw_data[ filtered_raw_data[&quot;user&quot;].isin(vd_users) &amp; filtered_raw_data[&quot;item&quot;].isin(tr_items) ] te_obsrv = filtered_raw_data[ filtered_raw_data[&quot;user&quot;].isin(te_users) &amp; filtered_raw_data[&quot;item&quot;].isin(tr_items) ] . Now that we have the validation and test users and their interactions, we will split such interactions into so-called &quot;validation and test train and test sets&quot;. . I know that this sounds convoluted, but is not that complex. The &quot;validation_train and test_train sets&quot;, comprising here 80% of the total validation and test sets, will be used to build what we could think as an input binary &quot;image&quot; (i.e. the binary matrix of clicks) to be &quot;encoded -&gt; decoded&quot; by the trained auto-encoder. On the other hand the &quot;validation_test and test_test sets&quot;, comprising here 20% of the total validation and test sets, will be used to compute the ranking metrics at validation/test time. If you want more details along with a toy example please go to the corresponding notebook in the repo. I will discuss this further in Section 4. . def split_train_test( data: pd.DataFrame, test_size: float ) -&gt; Tuple[pd.DataFrame, pd.DataFrame]: data_grouped_by_user = data.groupby(&quot;user&quot;) tr_list, te_list = list(), list() np.random.seed(98765) for i, (nm, group) in enumerate(data_grouped_by_user): n_items_u = len(group) if n_items_u &gt;= 5: idx = np.zeros(n_items_u, dtype=&quot;bool&quot;) idx[ np.random.choice( n_items_u, size=int(test_size * n_items_u), replace=False ).astype(&quot;int64&quot;) ] = True tr_list.append(group[np.logical_not(idx)]) te_list.append(group[idx]) else: tr_list.append(group) data_tr = pd.concat(tr_list) data_te = pd.concat(te_list) return data_tr, data_te def numerize(tp: pd.DataFrame, user2id: Dict, item2id: Dict) -&gt; pd.DataFrame: user = [user2id[x] for x in tp[&quot;user&quot;]] item = [item2id[x] for x in tp[&quot;item&quot;]] return pd.DataFrame(data={&quot;user&quot;: user, &quot;item&quot;: item}, columns=[&quot;user&quot;, &quot;item&quot;]) . vd_items_tr, vd_items_te = split_train_test(vd_obsrv, test_size=0.2) te_items_tr, te_items_te = split_train_test(te_obsrv, test_size=0.2) . And that&#39;s it regarding to data preparation. We can now move to the model itself. . 3 $ text{Mult-VAE}^{ text{PR}}$: the code . After the explanation in Section 1 you might expect the code to look rather complex. However, you might feel disappointed/pleased when you see how simple it really is. . In the original publications the authors used a one hidden layer MLP as generative model. There they say that deeper architectures do not improve the results, which I find it to be true after having run over 60 experiments. With that it mind, let&#39;s first have a look the model $ I rightarrow 600 rightarrow 200 rightarrow 600 rightarrow I$, where $I$ is the total number of items: . . Figure 1. $ text{Mult-VAE}^{ text{PR}}$ architecture. The colors in the Figure are my attempt to emphasize the reparameterization trick. . In code, the figure above is: . #collapse-hide from typing import List import numpy as np import mxnet as mx from mxnet import autograd, gluon, nd from mxnet.gluon import nn, HybridBlock . . /usr/local/lib/python3.6/site-packages/h5py/__init__.py:36: FutureWarning: Conversion of the second argument of issubdtype from `float` to `np.floating` is deprecated. In future, it will be treated as `np.float64 == np.dtype(float).type`. from ._conv import register_converters as _register_converters . 3.1 Encoder . class VAEEncoder(HybridBlock): def __init__(self, q_dims: List[int], dropout: List[float]): super().__init__() # last dim multiplied by two for the reparameterization trick q_dims_ = q_dims[:-1] + [q_dims[-1] * 2] with self.name_scope(): self.q_layers = nn.HybridSequential(prefix=&quot;q_net&quot;) for p, inp, out in zip(dropout, q_dims_[:-1], q_dims_[1:]): self.q_layers.add(nn.Dropout(p)) self.q_layers.add(nn.Dense(in_units=inp, units=out)) def hybrid_forward(self, F, X): h = F.L2Normalization(X) for i, layer in enumerate(self.q_layers): h = layer(h) if i != len(self.q_layers) - 1: h = F.tanh(h) else: mu, logvar = F.split(h, axis=1, num_outputs=2) return mu, logvar . 3.2 Decoder . class Decoder(HybridBlock): def __init__(self, p_dims: List[int], dropout: List[float]): super().__init__() with self.name_scope(): self.p_layers = nn.HybridSequential(prefix=&quot;p_net&quot;) for p, inp, out in zip(dropout, p_dims[:-1], p_dims[1:]): self.p_layers.add(nn.Dropout(p)) self.p_layers.add(nn.Dense(in_units=inp, units=out)) def hybrid_forward(self, F, X): h = X for i, layer in enumerate(self.p_layers): h = layer(h) if i != len(self.p_layers) - 1: h = F.tanh(h) return h . 3.3 The model . class MultiVAE(HybridBlock): def __init__( self, p_dims: List[int], dropout_enc: List[float], dropout_dec: List[float], q_dims: List[int] = None, ): super().__init__() self.encode = VAEEncoder(q_dims, dropout_enc) self.decode = Decoder(p_dims, dropout_dec) def hybrid_forward(self, F, X): mu, logvar = self.encode(X) std = F.exp(0.5 * logvar) eps = F.random.normal_like(std) sampled_z = mu + float(autograd.is_training()) * eps * std return self.decode(sampled_z), mu, logvar . Before I move on, let me mention (and appreciate) one of the many nice &quot;little&quot; things that Mxnet&#39;s Gluon has to offer. You will notice the use of HybridBlock and the use of the input F (the backend) when we define the forward pass, or more precisely, the hybrid_forward pass. One could write a full post on the joys of HybridBlocks and how nicely and easily the guys that developed Gluon brought together the flexibility of imperative frameworks (e.g. Pytorch) and the speed of declarative frameworks (e.g. Tensorflow) together. If you want to learn the details go here, but believe me, this is FAST. . Having said that, there is only one more piece that we need to have the complete model, the loss function in Eq (12). . def vae_loss_fn(inp, out, mu, logvar, anneal): # firt term neg_ll = -nd.mean(nd.sum(nd.log_softmax(out) * inp, -1)) # second term without beta KLD = -0.5 * nd.mean(nd.sum(1 + logvar - nd.power(mu, 2) - nd.exp(logvar), axis=1)) # &quot;full&quot; loss (anneal is beta in the expressions above) return neg_ll + anneal * KLD . In the paper the authors also use a Multinomial Denoising Autoencoder (Mult-DAE). The architecture is identical to that of the $ text{Mult-VAE}^{ text{PR}}$ apart from the fact that there is no variational aspect. I have implemented the Mult-DAE and run multiple experiments with it. However, given its simplicity and an already lengthy post, I will not discuss the corresponding code here. . Let&#39;s have a look to the MultiVAE . I = 50000 q_dims = [I] + [600, 200] p_dims = [200, 600] + [I] dropout_enc = [0.5, 0.] dropout_dec = [0., 0.] . vae_model = MultiVAE( p_dims=p_dims, q_dims=q_dims, dropout_enc=dropout_enc, dropout_dec=dropout_dec, ) vae_model . MultiVAE( (encode): VAEEncoder( (q_layers): HybridSequential( (0): Dropout(p = 0.5, axes=()) (1): Dense(50000 -&gt; 600, linear) (2): Dropout(p = 0.0, axes=()) (3): Dense(600 -&gt; 400, linear) ) ) (decode): Decoder( (p_layers): HybridSequential( (0): Dropout(p = 0.0, axes=()) (1): Dense(200 -&gt; 600, linear) (2): Dropout(p = 0.0, axes=()) (3): Dense(600 -&gt; 50000, linear) ) ) ) . Note that following the original implementation, I apply dropout at the input layer for both $ text{Mult-VAE}^{ text{PR}}$ and $ text{Mult-DAE}$ to avoid overfitting. I also include the option for applying dropout throughout the network. . Note that even though I have explored different dropouts, the best way of addressing the interplay between dropout, weight decay, $ beta$, etc, and the architecture is using &quot;proper&quot; hyperparamter optimization. . 4. Train, validate and test model . So far we have explained (a bit) the math behind the model, prepared the data and build the (relatively) simple model. Now is time to train it. . If you go to prepare_data.py in the repo, you will see that the results of the data preparation in Section 2 are saved into pickle files and are later loader in main_mxnet.py by a class called Dataloader in the module utils. This is of course inspired by the original implementation and the already mentioned Pytorch implementation. . Let&#39;s have a look using this time the Movilens dataset . #collapse-hide from utils.data_loader import DataLoader from utils.metrics import NDCG_binary_at_k_batch, Recall_at_k_batch . . data_loader = DataLoader(DATA_DIR / &quot;movielens_processed&quot;) n_items = data_loader.n_items train_data = data_loader.load_data(&quot;train&quot;) valid_data_tr, valid_data_te = data_loader.load_data(&quot;validation&quot;) test_data_tr, test_data_te = data_loader.load_data(&quot;test&quot;) train_data . &lt;116677x20108 sparse matrix of type &#39;&lt;class &#39;numpy.float32&#39;&gt;&#39; with 8538846 stored elements in Compressed Sparse Row format&gt; . As you can see, the training data (same applies to validation and test) is the binary sparse matrix of interactions. Have a look to the class DataLoader if you want a few more details on how it is built. . 4.1 Annealing schedule . As mentioned before, we can interpret the Kullback-Leiber divergence as a regularization term. With that in mind, in a procedure inspired by Samuel R. Bowman et al, 2016 [6], Liang and co-authors linearly annealed the KL term (i.e. increase $ beta$) slowly over a large number of training steps. . More specifically, the authors anneal the KL divergence all the way to $ beta$ = 1, reaching that value at around 80% of the total number of epochs used during the process. They then identify the best performing $ beta$ based on the peak validation metric, and retrain the model with the same annealing schedule, but stop increasing $ beta$ after reaching that value. . If we go to their implementation, these are the specifics of the process: using a batch size of 500 they set the total number of annealing steps to 200000. Given that the training dataset has a size of 116677, every epoch has 234 training steps. Their anneal_cap value, i.e. the maximum annealing reached during training, is set to 0.2, and during training they use the following approach: . if total_anneal_steps &gt; 0: anneal = min(anneal_cap, 1. * update_count / total_anneal_steps) else: anneal = anneal_cap . where update_count will increase by 1 every training step/batch. They use 200 epochs, therefore, if we do the math, the anneal_cap value will stop increasing when update_count / total_anneal_steps = 0.2, i.e. after 40000 training steps, or in other words, after around 170 epochs, i.e. $ sim$80% of the total number of epochs. . Whit that in mind my implementation looks like this: . batch_size = 500 anneal_epochs = None anneal_cap = 0.2 constant_anneal = False n_epochs = 200 . training_steps = len(range(0, train_data.shape[0], batch_size)) try: total_anneal_steps = ( training_steps * (n_epochs - int(n_epochs * 0.2)) ) / anneal_cap except ZeroDivisionError: assert ( constant_anneal ), &quot;if &#39;anneal_cap&#39; is set to 0.0 &#39;constant_anneal&#39; must be set to &#39;True&quot; . once the total_anneal_steps is set, the only thing left is to define the training and validation steps. If you are familiar with Pytorch, the next two functions will be look very familiar to you: . 4.2 Train Step . def train_step(model, optimizer, data, epoch): running_loss = 0.0 global update_count N = data.shape[0] idxlist = list(range(N)) np.random.shuffle(idxlist) training_steps = len(range(0, N, batch_size)) with trange(training_steps) as t: for batch_idx, start_idx in zip(t, range(0, N, batch_size)): t.set_description(&quot;epoch: {}&quot;.format(epoch + 1)) end_idx = min(start_idx + batch_size, N) X_inp = data[idxlist[start_idx:end_idx]] X_inp = nd.array(X_inp.toarray()).as_in_context(ctx) if constant_anneal: anneal = anneal_cap else: anneal = min(anneal_cap, update_count / total_anneal_steps) update_count += 1 with autograd.record(): if model.__class__.__name__ == &quot;MultiVAE&quot;: X_out, mu, logvar = model(X_inp) loss = vae_loss_fn(X_inp, X_out, mu, logvar, anneal) train_step.anneal = anneal elif model.__class__.__name__ == &quot;MultiDAE&quot;: X_out = model(X_inp) loss = -nd.mean(nd.sum(nd.log_softmax(X_out) * X_inp, -1)) loss.backward() trainer.step(X_inp.shape[0]) running_loss += loss.asscalar() avg_loss = running_loss / (batch_idx + 1) t.set_postfix(loss=avg_loss) . 4.3 Validation step . def eval_step(data_tr, data_te, data_type=&quot;valid&quot;): running_loss = 0.0 eval_idxlist = list(range(data_tr.shape[0])) eval_N = data_tr.shape[0] eval_steps = len(range(0, eval_N, batch_size)) n100_list, r20_list, r50_list = [], [], [] with trange(eval_steps) as t: for batch_idx, start_idx in zip(t, range(0, eval_N, batch_size)): t.set_description(data_type) end_idx = min(start_idx + batch_size, eval_N) X_tr = data_tr[eval_idxlist[start_idx:end_idx]] X_te = data_te[eval_idxlist[start_idx:end_idx]] X_tr_inp = nd.array(X_tr.toarray()).as_in_context(ctx) with autograd.predict_mode(): if model.__class__.__name__ == &quot;MultiVAE&quot;: X_out, mu, logvar = model(X_tr_inp) loss = vae_loss_fn(X_tr_inp, X_out, mu, logvar, train_step.anneal) elif model.__class__.__name__ == &quot;MultiDAE&quot;: X_out = model(X_tr_inp) loss = -nd.mean(nd.sum(nd.log_softmax(X_out) * X_tr_inp, -1)) running_loss += loss.asscalar() avg_loss = running_loss / (batch_idx + 1) # Exclude examples from training set X_out = X_out.asnumpy() X_out[X_tr.nonzero()] = -np.inf n100 = NDCG_binary_at_k_batch(X_out, X_te, k=100) r20 = Recall_at_k_batch(X_out, X_te, k=20) r50 = Recall_at_k_batch(X_out, X_te, k=50) n100_list.append(n100) r20_list.append(r20) r50_list.append(r50) t.set_postfix(loss=avg_loss) n100_list = np.concatenate(n100_list) r20_list = np.concatenate(r20_list) r50_list = np.concatenate(r50_list) return avg_loss, np.mean(n100_list), np.mean(r20_list), np.mean(r50_list) . I have widely discussed the evaluation metrics (NDCG@k and Recall@k) in a number of notebooks in this repo (and corresponding posts). Therefore, with that in mind and with the aim of not making this a more &quot;infinite notebook&quot;, I will not describe the corresponding implementation here. If you want details on those evaluation metrics, please go the metrics.py module in utils. The code there is a very small adaptation to the one in the original implementation. . 4.4 Running the process . Let&#39;s define the model, prepare the set up and run a small sample (of course, ignore the results printed. I only want to illustrate how to run the model) . model = MultiVAE( p_dims=[200, 600, n_items], q_dims=[n_items, 600, 200], dropout_enc=[0.5, 0.0], dropout_dec=[0.0, 0.0], ) . model . MultiVAE( (encode): VAEEncoder( (q_layers): HybridSequential( (0): Dropout(p = 0.5, axes=()) (1): Dense(20108 -&gt; 600, linear) (2): Dropout(p = 0.0, axes=()) (3): Dense(600 -&gt; 400, linear) ) ) (decode): Decoder( (p_layers): HybridSequential( (0): Dropout(p = 0.0, axes=()) (1): Dense(200 -&gt; 600, linear) (2): Dropout(p = 0.0, axes=()) (3): Dense(600 -&gt; 20108, linear) ) ) ) . ctx = mx.gpu() if mx.context.num_gpus() else mx.cpu() model.initialize(mx.init.Xavier(), ctx=ctx) model.hybridize() optimizer = mx.optimizer.Adam(learning_rate=0.001, wd=0.) trainer = gluon.Trainer(model.collect_params(), optimizer=optimizer) . stop_step = 0 update_count = 0 eval_every = 1 stop = False for epoch in range(1): train_step(model, optimizer, train_data[:2000], epoch) if epoch % eval_every == (eval_every - 1): val_loss, n100, r20, r50 = eval_step(valid_data_tr[:1000], valid_data_te[:1000]) print(&quot;=&quot; * 80) print( &quot;| valid loss {:4.3f} | n100 {:4.3f} | r20 {:4.3f} | &quot; &quot;r50 {:4.3f}&quot;.format(val_loss, n100, r20, r50) ) print(&quot;=&quot; * 80) . epoch: 1: 100%|██████████| 4/4 [00:04&lt;00:00, 1.25s/it, loss=737] valid: 100%|██████████| 2/2 [00:01&lt;00:00, 1.12it/s, loss=562] . ================================================================================ | valid loss 561.928 | n100 0.006 | r20 0.003 | r50 0.006 ================================================================================ . . And with a few more rings and bells (e.g. optional learning rate scheduler, early stopping, etc...) this is exactly the code that you will find in main_mxnet.py. . Before I move to the next, final section, just a quick comment about something I normally find in these scientific publications. Normally, once they have found the best hyperparameters on the validation set, they test the model on the test set. . # Run on test data with best model model.load_parameters(str(model_weights / (model_name + &quot;.params&quot;)), ctx=ctx) test_loss, n100, r20, r50 = eval_step( test_data_tr, test_data_te, data_type=&quot;test&quot; ) . In &quot;real-life&quot; scenarios, there would be one additional step, the one merging the train and validation sets, re-training the model with the best hyperparameters and then testing on the test set. In any case, since here my goal is not to build a real-life system, I will follow the same procedure to that found in the original implementation. . Time now to have a look to the results obtained with both Pytorch and Mxnet. . 5. Summary of the results . let me remind again the annealing schedule described in Section 4.1. Basically, we gradually anneal to $ beta = 1$, which is reached at around 80% of the total number of epochs, and record the best anneal parameter ($ beta_{best}$). Then we apply the same annealing schedule but with $ beta_{best}$, i.e. we anneal to $ beta_{best}$ reaching that value at around 80% of the total number of epochs. . #collapse-hide from utils.plot_utils import plot_anneal_schedule, find_best, plot_metric_vs_loss, plot_ndcg_vs_pdims plot_anneal_schedule() . . Figure 2. Same annealing schedule as on Liang et al 2018 for 3 different architectures and for the Movielens and the Amazon datasets using Pytorch and Mxnet. During the annealing schedule, $ beta=1$ is reached at 170 epochs (out of 200, i.e. 85%) . #collapse-hide best_results = pd.concat([ find_best(dl_frame=&#39;pt&#39;, model=&#39;vae&#39;), find_best(dl_frame=&#39;pt&#39;, model=&#39;dae&#39;), find_best(dl_frame=&#39;mx&#39;, model=&#39;vae&#39;), find_best(dl_frame=&#39;mx&#39;, model=&#39;dae&#39;), ]).reset_index(drop=True) best_results.sort_values([&quot;dataset&quot;, &quot;model&quot;]).reset_index(drop=True) . . dataset dl_frame model p_dims weight_decay lr lr_scheduler anneal_cap best_epoch loss n100 r20 r50 . 0 amazon | Pytorch | dae | [50,150] | 0.0 | 0.001 | False | NA | 28 | 87.588 | 0.091 | 0.120 | 0.182 | . 1 amazon | Mxnet | dae | [100,300] | 0.0 | 0.001 | False | NA | 18 | 85.985 | 0.090 | 0.119 | 0.182 | . 2 amazon | Pytorch | vae | [300,900] | 0.0 | 0.001 | False | 0.7 | 170 | 92.263 | 0.101 | 0.137 | 0.204 | . 3 amazon | Mxnet | vae | [200,600] | 0.0 | 0.001 | False | 0 | 8 | 85.310 | 0.090 | 0.118 | 0.179 | . 4 movielens | Pytorch | dae | [200,600] | 0.0 | 0.001 | False | NA | 136 | 349.714 | 0.418 | 0.386 | 0.530 | . 5 movielens | Mxnet | dae | [200, 600] | 0.0 | 0.005 | True | NA | 184 | 348.841 | 0.424 | 0.393 | 0.536 | . 6 movielens | Pytorch | vae | [200, 600] | 0.0 | 0.005 | True | 0.2 | 155 | 365.372 | 0.427 | 0.398 | 0.538 | . 7 movielens | Mxnet | vae | [200,600] | 0.0 | 0.001 | False | 0 | 101 | 350.479 | 0.417 | 0.388 | 0.531 | . Table 1. Best performing experiments (in terms of NDCG@10) among all the experiments I run (which can be found in the run_experiment.sh file in the repo). A csv file with the results for all experiments run can be found in the all_results.csv file in the repo. . Figure 1 reproduces the same annealing schedule for 3 different architectures and for the Movielens and the Amazon datasets using Pytorch and Mxnet. During the annealing schedule, $ beta=1$ is reached at 170 epochs (out of 200, i.e. 85%). In addition, I have also used early stopping with a &quot;patience&quot; of 20 epochs, which is why none of the experiments reaches the 200 epochs. The vertical lines in the figure indicate the epoch at which the best NDGC@100 is reached, and the corresponding $ beta$ value is indicated in the top x-axis. . On the other hand, Table 1 shows the best results I obtained for all the experiments I run, which you can find in this repo in the file run_experiments.sh. . At first sight it is apparent how different the two deep learning frames behave. I find Pytorch to perform a bit better than Mxnet and to be more stable across experiments. This is something that I keep finding every time I use these two frames for the same exercise. For example, here, using Hierarchical Attention networks. I actually believe this is due to the fact that I know (or have used) more Pytorch than Mxnet. Nonetheless, at this stage it is clear for me that I need to do a proper benchmark exercise between these two deep learning libraries. . Focusing on the results shown in Figure 1, the first apparent result is that the Mxnet implementation performs better with little or no regularization. In fact, I have run over 60 experiments and, as shown in Table 1, the best results when using Mult-VAE and Mxnet are obtained with no regularization, i.e. a denoising autoencoder with the reparametrization trick. Furthermore, the best overall metrics with Mxnet are obtained using the Mult-DAE (NDCG@100 = 0.424). . If we also focus in the differences between datasets, it is first apparent that the metrics are significantly smaller for the Amazon dataset relative to those obtained with the Movielens dataset. This was of course expected since as I mentioned in Section 2.1 the Amazon dataset is 13 times more sparse that the Movielens dataset, i.e. significantly more challenging. In addition, we see that the Pytorch implementation shows a very stable behavior for both datasets and architectures, reaching the best NDCG@10 later in the training epochs in the case of the Amazon dataset. Again this is different in the case of the Mxnet implementation, where we see less consistency and the maximum NDCG@10 being reached very early during training for both datasets. . #collapse-hide plot_ndcg_vs_pdims() . . Figure 3 NDCG100 (aka n100) plotted against the first dimension of the decoder for the following architectures: $ small{ i) space I rightarrow 150 rightarrow 50 rightarrow 150 rightarrow I}$, $ small{ ii) space I rightarrow 300 rightarrow 100 rightarrow 300 rightarrow I}$, $ small{ iii) space I rightarrow 600 rightarrow 200 rightarrow 600 rightarrow I}$ and $ small{ iv) space I rightarrow 900 rightarrow 300 rightarrow 900 rightarrow I}$ . On the other hand, Liang et al mentioned in their paper that deeper architectures did not lead to any improvement. This is consistent with the results I found in my experiments. In fact, Figure 3 shows the NDCG100 (refereed in the figure as n100) vs the first dimension of the decoder for four different architectures. As we can see in the figure, even concentrating in architectures with the same number of layers, adding neurons per layer was not particularly helpful beyond a certain number (50 and 200 for the Movilens and the Amazon dataset respectively). . #collapse-hide plot_metric_vs_loss() . . Figure 4. NDGC@100 (n100), and Recall@20 (r20) and Recall@50 (r50) plotted against the loss for all experiments I run . Before I end up this exercise I wanted to emphasize a result I have already discussed in the past (see here) and that is illustrated in Fig 4. . Fig 2 shows that, in general, the best ranking metrics do not correspond to the best loss values. Even though the the reconstruction of the input matrix of clicks might be worse, the ranking metrics might still improve. This is an important and not uncommon results, and something one has to bear in mind when building real world recommendation systems. When building recommendation algorithms we are not interested in achieving the best classification/regression loss, but in producing the best recommendations, which is more related to information retrieval effectiveness, and therefore ranking metrics. For more information on this and many other aspects of recommendation systems, I recommend this fantastic book. Chapter 7 in that book focuses on evaluation metrics. . And with this, I conclude my experimentation around the Mult-VAE with Pytorch and Mxnet . The next, most immediate projects I want to add to the repo are: . Sequential Variational Autoencoders for Collaborative Filtering [7] | LightGCN: Simplifying and Powering Graph Convolution Network for Recommendation [8] | But before that, I will be re-visiting the [nlp-stuff repo] and also updating the pytorch-widedeep package. . If you manage to read all that, I hope you found it useful. . References: . [1] Dawen Liang, Rahul G. Krishnan, Matthew D. Hoffman, Tony Jebara, 2018. Variational Autoencoders for Collaborative Filtering: arXiv:1802.05814v1 . [2] Diederik P Kingma, Max Welling, 2014. Auto-Encoding Variational Bayes: arXiv:1312.6114v10 . [3] Maurizio Ferrari Dacrema, Paolo Cremonesi, Dietmar Jannach. Are We Really Making Much Progress? A Worrying Analysis of Recent Neural Recommendation Approaches: arXiv:1907.06902v3 . [4] J. McAuley, C. Targett, J. Shi, A. van den Hengel. 2015. Image-based recommendations on styles and substitutes. arXiv:1506.04757v1 . [5] R. He, J. McAuley, 2016. Modeling the visual evolution of fashion trends with one-class collaborative filtering. arXiv:1602.01585v1 . [6] Samuel R. Bowman, Luke Vilnis, Oriol Vinyals, Andrew M. Dai, Rafal Jozefowicz, Samy Bengio, 2016. Generating Sentences from a Continuous Space: arXiv:1511.06349v4 . [7] Noveen Sachdeva, Giuseppe Manco, Ettore Ritacco, Vikram Pudi, 2018. Sequential Variational Autoencoders for Collaborative Filtering: arXiv:1811.09975v1 . [8] Xiangnan He, Kuan Deng, Xiang Wang, Yan Li, Yongdong Zhang, Meng Wang, 2020. LightGCN: Simplifying and Powering Graph Convolution Network for Recommendation arXiv:2002.02126v2 .",
            "url": "https://jrzaurin.github.io/infinitoml/2020/05/15/mult-vae.html",
            "relUrl": "/2020/05/15/mult-vae.html",
            "date": " • May 15, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Coming soon. Don’t expect much though… .",
          "url": "https://jrzaurin.github.io/infinitoml/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  
  

  
  

  
  

  
  

  
      ,"page8": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jrzaurin.github.io/infinitoml/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}